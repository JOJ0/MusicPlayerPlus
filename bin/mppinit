#!/bin/bash
#
# mppinit - initialize MusicPlayerPlus
#
# Copy and configure default configuration files in $HOME/.config/mpcplus/
# Setup default tmux configuration for this user
# Install required pip modules if not already installed
# Optionally perform Beets initialization and metadata retrieval

MPPCDIR=/usr/share/musicplayerplus
CONFDIR=${MPPCDIR}/mpcplus
SCPTDIR=${MPPCDIR}/scripts
CCPTDIR=${MPPCDIR}/calliope
CONF=${HOME}/.config
MPDCONFDIR="${CONF}/mpd"
MPDCONF="${MPDCONFDIR}/mpd.conf"
BEETSCONFDIR="${CONF}/beets"
BEETSLOGDIR="${BEETSCONFDIR}/logs"
BEETSCONF="${BEETSCONFDIR}/config.yaml"
BEETSGENR="${BEETSCONFDIR}/genres"
CALIPCONFDIR="${CONF}/calliope"
CALIPCONF="${CALIPCONFDIR}/calliope.conf"
KITTYCONFDIR="${CONF}/kitty"
KITTYCONF="${KITTYCONFDIR}/mpplus.conf"
MOPIDCONFDIR="${CONF}/mopidy"
MOPIDCONF="${MOPIDCONFDIR}/mopidy.conf"
NAVIDCONFDIR="${CONF}/navidrome"
NAVIDCONF="${NAVIDCONFDIR}/navidrome.toml"
YTDLPCONFDIR="${CONF}/yt-dlp"
YTDLPCONF="${YTDLPCONFDIR}/config"
CFGS="config-art.conf default_cover.png fzmp.conf"
SCPS="album_cover.sh cover_obs.sh mpcplus-art.sh mppsplash-dual.sh"
EXT_MOPIDY="Mopidy-Beets Mopidy-TuneIn Mopidy-Local Mopidy-Podcast \
            Mopidy-Podcast-iTunes Mopidy-Mobile Mopidy-MPD Mopidy-Scrobbler"

BOLD=$(tput bold)
NORM=$(tput sgr0)
IP="<ip address>"
mpd_music="~/Music"
exp_music="${HOME}/Music"

usage() {
  printf "\nUsage: mppinit [-a] [-b] [-d] [-e] [-o] [-q] [-r] [-U] [-y] [-u] "
  printf "[bandcamp|import|metadata|mopidy|mpd|navidrome|soundcloud|sync|yams]"
  printf "\nWhere:"
  printf "\n\t'-a' use AcousticBrainz for acoustic audio analysis (deprecated)"
  printf "\n\t'-b' use Blissify for MPD acoustic audio analysis"
  printf "\n\t'-d' install latest Beets development branch rather than"
  printf "\n\t\tthe latest stable release (for testing purposes)"
  printf "\n\t'-e' use Essentia for Beets acoustic audio analysis (default)"
  printf "\n\t'-o' indicates overwrite any pre-existing configuration"
  printf "\n\t'-q' indicates quiet execution, no status messages"
  printf "\n\t'-r' indicates remove service"
  printf "\n\t\tsupported service removals: mopidy navidrome"
  printf "\n\t'-U' indicates do not upgrade installed Python modules"
  printf "\n\t'-y' indicates answer 'yes' to all and proceed"
  printf "\n\t'-u' displays this usage message and exits\n"
  printf "\n\t'bandcamp' downloads all albums in your Bandcamp collections"
  printf "\n\t'import' performs a Beets music library import"
  printf "\n\t'metadata' performs a library metadata update"
  printf "\n\t'mopidy' installs and configures Mopidy extensible music server"
  printf "\n\t\tNote: activating Mopidy deactivates MPD"
  printf "\n\t'mpd' activates the MPD music server and deactivates Mopidy"
  printf "\n\t'navidrome' installs and configures Navidrome music server"
  printf "\n\t\tNote: 'mppinit navidrome <version>' can be used to specify"
  printf "\n\t\tan alternate version of Navidrome to download and install"
  printf "\n\t'soundcloud' downloads all favorites in your Soundcloud account"
  printf "\n\t'sync' synchronizes the music library location across configs"
  printf "\n\t'yams' activates the YAMS Last.fm scrobbler service\n"
  printf "\n\n'mppinit' must be run prior to sync, metadata, bandcamp,"
  printf "\nmopidy, navidrome, soundcloud, or import\n\n"
  exit 1
}

get_ip() {
  have_hostname=`type -p hostname`
  if [ "${have_hostname}" ]
  then
    IP=`hostname -I | awk '{print $1}'`
  else
    have_ip=`type -p ip`
    if [ "${have_ip}" ]
    then
      IP=`ip route get 1.2.3.4 | head -1 | awk '{print $7}'`
    else
      IP="<ip address>"
    fi
  fi
}

create_new_profile() {
  local proterm="$1"
  local proname="$2"
  local profont="$3"
  if [ "${proterm}" == "gnome" ]
  then
    local profile_ids=($(dconf list $dconfdir/ | grep ^: |\
        sed 's/\///g' | sed 's/://g'))
  fi
  if [ "${proterm}" == "tilix" ]
  then
    local profile_ids=($(dconf list $dconfdir/ | grep -v ^list |\
        sed 's/\///g' | sed 's/://g'))
  fi
  local profile_ids_old="$(dconf read "$dconfdir"/list | tr -d "]")"
  local profile_id="$(uuidgen)"
  [ "${debug}" ] && {
    echo "profile_ids_old=${profile_ids_old}"
    echo "profile_id=${profile_id}"
  }

  if [ -z "$profile_ids_old" ]
  then
    if [ ${#profile_ids[@]} -gt 0 ]
    then
      for id in "${!profile_ids[@]}"
      do
        profile_ids[${id}]="'profile_ids[${id}]',"
      done
      dconf write $dconfdir/list "[${profile_ids[*]} '$profile_id']" 2> /dev/null
      [ "${debug}" ] && {
        echo "A: dconf write $dconfdir/list [${profile_ids[*]} '$profile_id']"
      }
    else
      dconf write $dconfdir/list "['$profile_id']" 2> /dev/null
      [ "${debug}" ] && {
        echo "B: dconf write $dconfdir/list ['$profile_id']"
      }
    fi
  else
    dconf write $dconfdir/list "${profile_ids_old}, '$profile_id']" 2> /dev/null
    [ "${debug}" ] && {
      echo "C: dconf write $dconfdir/list ${profile_ids_old}, '$profile_id']"
    }
  fi

  if [ "${proterm}" == "gnome" ]
  then
    profile_path="$dconfdir/:$profile_id"
  fi
  if [ "${proterm}" == "tilix" ]
  then
    profile_path="$dconfdir/$profile_id"
  fi
  dconf write $profile_path/visible-name "'$proname'" 2> /dev/null

  # MusicPlayerPlus profiles want a semi-transparent background
  dconf write $profile_path/background-color "'rgb(0,0,0)'" 2> /dev/null
  dconf write $profile_path/foreground-color "'rgb(255,255,255)'" 2> /dev/null
  dconf write $profile_path/cursor-shape "'underline'" 2> /dev/null
  dconf write $profile_path/cursor-blink-mode "'off'" 2> /dev/null
  dconf write $profile_path/use-theme-colors "false" 2> /dev/null
  if [ "${proterm}" == "gnome" ]
  then
    dconf write $profile_path/use-theme-transparency "false" 2> /dev/null
    dconf write $profile_path/use-transparent-background "true" 2> /dev/null
  fi
  dconf write $profile_path/background-transparency-percent "50" 2> /dev/null
  dconf write $profile_path/use-system-font "false" 2> /dev/null
  dconf write $profile_path/font "'Monospace ${profont}'" 2> /dev/null
}

create_profiles() {
  have_gnome=`type -p gnome-terminal`
  have_tilix=`type -p tilix`
  [ "${have_gnome}" ] || [ "${have_tilix}" ] && {
    have_dconf=`type -p dconf`
    have_gsettings=`type -p gsettings`
    [ "${have_dconf}" ] && [ "${have_gsettings}" ] || {
      printf "\n\nGnome and Tilix terminal emulators require profiles."
      printf "\nIn order to create profiles for these terminal emulators,"
      printf "\nthe 'dconf' and glib2' packages are required."
      printf "\n\nTo use either the Gnome or Tilix terminal emulator,"
      printf "\ninstall these packages with your package manager."
      printf "\nAfter installing these dependencies, run 'mppinit profiles'."
      printf "\nSkipping terminal profiles creation. MusicPlayerPlus will"
      printf "\nuse the Kitty terminal emulator.\n"
      return
    }
  }
  # If no MusicPlayerPlus and Visualizer terminal profiles exist, create them
  [ "${quiet}" ] || {
    printf "\n\tCreating MusicPlayerPlus terminal profiles ..."
  }
  declare -a profiles
  [ "${have_gnome}" ] && {
    dconfdir=/org/gnome/terminal/legacy/profiles:
    profiles=($(gsettings get org.gnome.Terminal.ProfilesList list | tr -d "[]\',"))

    for profile_name in MusicPlayer Visualizer
    do
      profile_exists=
      fontsize=8
      [ "${profile_name}" == "MusicPlayer" ] && fontsize=32
      if [ "$profiles" = "" ]
      then
        create_new_profile gnome ${profile_name} ${fontsize}
      else
        for i in ${!profiles[*]}
        do
          visname="$(dconf read $dconfdir/:${profiles[i]}/visible-name)"
          [ "${visname}" == "'${profile_name}'" ] && profile_exists=1
          [ "$profile_exists" ] && break
        done
      fi

      [ "$profile_exists" ] || {
        create_new_profile gnome ${profile_name} ${fontsize}
      }
    done
  }

  [ "${have_tilix}" ] && {
    # Create Tilix profiles, similar to Gnome-terminal's
    dconfdir=/com/gexperts/Tilix/profiles
    profiles=($(gsettings get com.gexperts.Tilix.ProfilesList list | tr -d "[]\',"))

    for profile_name in MusicPlayer Visualizer
    do
      profile_exists=
      fontsize=8
      [ "${profile_name}" == "MusicPlayer" ] && fontsize=32

      if [ "$profiles" = "" ]
      then
        create_new_profile tilix ${profile_name} ${fontsize}
      else
        for i in ${!profiles[*]}
        do
          visname="$(dconf read $dconfdir/${profiles[i]}/visible-name)"
          [ "${visname}" == "'${profile_name}'" ] && profile_exists=1
          [ "$profile_exists" ] && break
        done
      fi

      [ "$profile_exists" ] || {
        create_new_profile tilix ${profile_name} ${fontsize}
      }
    done
  }
}

pip_install() {
  mod="$1"
  if pip list | grep ${mod} > /dev/null
  then
    if [ "${upgrade}" ]
    then
      [ "${quiet}" ] || {
        printf " upgrade ${mod},"
      }
      ${PYTHON} -m pip install --user --upgrade ${mod} > /dev/null 2>&1
    else
      [ "${quiet}" ] || {
        printf " ${mod} installed,"
      }
    fi
  else
    [ "${quiet}" ] || {
      printf " install ${mod},"
    }
    ${PYTHON} -m pip install --user ${mod} > /dev/null 2>&1
  fi
}

init_mopidy() {
  # Mopidy requires GStreamer >= 1.14.0 with Python bindings.
  debian=
  arch=
  [ -f /etc/os-release ] && . /etc/os-release
  [ "${ID_LIKE}" == "debian" ] && debian=1
  [ "${ID}" == "arch" ] && arch=1
  if [ "${debian}" ]
  then
    APT=
    have_apt=`type -p apt`
    if [ "${have_apt}" ]
    then
      APT=apt
    else
      have_aptget=`type -p apt-get`
      if [ "${have_aptget}" ]
      then
        APT=apt-get
      else
        echo "Could not locate apt or apt-get."
        echo "Skipping GStreamer installation."
      fi
    fi
    [ "${APT}" ] && {
      sudo ${APT} install python3-gst-1.0 \
                          gir1.2-gstreamer-1.0 \
                          gir1.2-gst-plugins-base-1.0 \
                          gstreamer1.0-plugins-good \
                          gstreamer1.0-plugins-ugly \
                          gstreamer1.0-tools -y
    }
  else
    if [ "${arch}" ]
    then
      sudo pacman -S --needed --noconfirm gst-python \
                                          gst-plugins-good \
                                          gst-plugins-ugly
    else
      DNF=
      have_dnf=`type -p dnf`
      if [ "${have_dnf}" ]
      then
        DNF=dnf
      else
        have_yum=`type -p yum`
        if [ "${have_yum}" ]
        then
          DNF=yum
        else
          echo "Could not locate dnf or yum."
          echo "Skipping GStreamer installation."
        fi
      fi
      [ "${DNF}" ] && {
        sudo ${DNF} install -y python3-gstreamer1 \
                               gstreamer1-plugins-good \
                               gstreamer1-plugins-ugly-free
      }
    fi
  fi

  # Install Mopidy from PyPi to get latest release (Mopidy-MPD needs >= 3.3.0)
  sudo ${PYTHON} -m pip install --upgrade mopidy > /dev/null 2>&1

  for extension in ${EXT_MOPIDY}
  do
    pip_install "${extension}"
  done

  # Disable MPD services
  systemctl --user is-enabled mpdstats.service >/dev/null 2>&1 && {
    systemctl --user disable mpdstats.service
  }
  systemctl --user is-active mpdstats.service >/dev/null 2>&1 && {
    systemctl --user stop mpdstats.service
  }
  systemctl --user is-enabled yams.service >/dev/null 2>&1 && {
    systemctl --user disable yams.service
  }
  systemctl --user is-active yams.service >/dev/null 2>&1 && {
    systemctl --user stop yams.service
  }
  systemctl --user is-enabled mpd.service >/dev/null 2>&1 && {
    systemctl --user disable mpd.service
    sudo systemctl --user --global disable mpd.service
  }
  systemctl --user is-enabled mpd.socket >/dev/null 2>&1 && {
    systemctl --user disable mpd.socket
    sudo systemctl --user --global disable mpd.socket
  }
  systemctl --user is-active mpd.service >/dev/null 2>&1 && {
    systemctl --user stop mpd.service
  }
  systemctl --user is-active mpd.socket >/dev/null 2>&1 && {
    systemctl --user stop mpd.socket
  }

  # Perform a local scan of the music library
  have_mopidy=`type -p mopidy`
  [ "${have_mopidy}" ] && mopidy local scan > /dev/null 2>&1 &

  # Reconfigure mpcplus with Mopidy visualizer data source
  [ -x ${SCPTDIR}/viz_data_src.sh ] && ${SCPTDIR}/viz_data_src.sh mopidy

  # Enable Mopidy services
  systemctl --user is-active webplugin.service >/dev/null 2>&1 || {
    systemctl --user start webplugin.service
  }
  systemctl --user is-enabled webplugin.service >/dev/null 2>&1 || {
    systemctl --user enable webplugin.service
  }
  systemctl --user is-active mopidy.service >/dev/null 2>&1 || {
    systemctl --user start mopidy.service
  }
  systemctl --user is-enabled mopidy.service >/dev/null 2>&1 || {
    systemctl --user enable mopidy.service
  }
}

remove_mopidy() {
  # Stop and Disable Navidrome service
  systemctl --user is-active mopidy.service >/dev/null 2>&1 && {
    systemctl --user stop mopidy.service
  }
  systemctl --user is-enabled mopidy.service >/dev/null 2>&1 && {
    systemctl --user disable mopidy.service
  }

  # Reconfigure mpcplus with MPD visualizer data source
  [ -x ${SCPTDIR}/viz_data_src.sh ] && ${SCPTDIR}/viz_data_src.sh mpd

  for extension in ${EXT_MOPIDY}
  do
    ${PYTHON} -m pip uninstall -y ${extension}
  done

  sudo ${PYTHHON} -m pip uninstall -y Mopidy
}

set_music_dir() {
  mpd_music=`grep ^music_directory ${MPDCONF}`
  [ "${mpd_music}" ] || mpd_music=`grep \#music_directory ${MPDCONF}`
  mpd_music=`echo ${mpd_music} | awk ' { print $2 } ' | sed -e "s/\"//g"`
  # Need to expand the tilda to $HOME
  exp_music="${mpd_music/#\~/$HOME}"
}

sync_music_dir() {
  set_music_dir
  if [ "${mpd_music}" ]
  then
    # Create mpd_music directory if it does not exist
    [ -d "${exp_music}" ] || mkdir -p ${exp_music}
    # Create playlists directory if it does not exist
    [ -d "${exp_music}/Playlists" ] || mkdir -p "${exp_music}/Playlists"
    # Sync playlist_directory in mpd.conf
    mpd_play=`grep ^playlist_directory ${MPDCONF}`
    mpd_play=`echo ${mpd_play} | awk ' { print $2 } ' | sed -e "s/\"//g"`
    [ "${mpd_music}/Playlists" == "${mpd_play}" ] || {
      cat ${MPDCONF} | sed -e "s%^playlist_directory .*%playlist_directory \"${mpd_music}/Playlists\"%" \ > /tmp/mpd$$
      cp /tmp/mpd$$ ${MPDCONF}
      rm -f /tmp/mpd$$
    }
    mpc_custom=1
    mpc_music=`grep ^mpd_music_dir ${HOME}/${MPCDIR}/config`
    [ "${mpc_music}" ] || {
      mpc_music=`grep \#mpd_music_dir ${HOME}/${MPCDIR}/config`
      mpc_custom=
    }
    mpc_music=`echo ${mpc_music} | awk ' { print $3 } '`
    [ "${mpd_music}" == "${mpc_music}" ] || {
      if [ "${mpc_custom}" ]
      then
        cat ${HOME}/${MPCDIR}/config | sed -e "s%^mpd_music_dir.*%mpd_music_dir = ${mpd_music}%" > /tmp/mpc$$
      else
        cat ${HOME}/${MPCDIR}/config | sed -e "s%#mpd_music_dir.*%mpd_music_dir = ${mpd_music}%" > /tmp/mpc$$
      fi
      cp /tmp/mpc$$ ${HOME}/${MPCDIR}/config
      rm -f /tmp/mpc$$
      cat ${HOME}/${MPCDIR}/config-art.conf | sed -e "s%^mpd_music_dir.*%mpd_music_dir = ${mpd_music}%" > /tmp/art$$
      cp /tmp/art$$ ${HOME}/${MPCDIR}/config-art.conf
      rm -f /tmp/art$$
    }
    bts_custom=1
    bts_music=`grep ^directory: ${BEETSCONF}`
    [ "${bts_music}" ] || {
      bts_music=`grep \#directory: ${BEETSCONF}`
      bts_custom=
    }
    bts_music=`echo ${bts_music} | awk ' { print $2 } '`
    [ "${mpd_music}" == "${bts_music}" ] || {
      if [ "${bts_custom}" ]
      then
        cat ${BEETSCONF} | \
          sed -e "s%^directory:.*%directory: ${mpd_music}%" \
              -e "s%playlist_dir:.*%playlist_dir: ${mpd_music}/Playlists%" \
              -e "s%relative_to:.*%relative_to: ${mpd_music}%" > /tmp/bts$$
      else
        cat ${BEETSCONF} | \
          sed -e "s%#directory:.*%directory: ${mpd_music}%" \
              -e "s%playlist_dir:.*%playlist_dir: ${mpd_music}/Playlists%" \
              -e "s%relative_to:.*%relative_to: ${mpd_music}%" > /tmp/bts$$
      fi
      cp /tmp/bts$$ ${BEETSCONF}
      rm -f /tmp/bts$$
    }
    # Sync music dir in mopidy.conf
    mop_music=`grep ^base_dir ${MOPIDCONF}`
    mop_music=`echo ${mop_music} | awk ' { print $3 } '`
    [ "${mpd_music}" == "${mop_music}" ] || {
      cat ${MOPIDCONF} | \
        sed -e "s%^base_dir = .*%base_dir = ${mpd_music}%" \
            -e "s%^base_dirs = .*%base_dirs = ${mpd_music}%" \
            -e "s%^playlists_dir = .*%playlists_dir = ${mpd_music}/Playlists%" \
            -e "s%^media_dir = .*%media_dir = ${mpd_music}%" > /tmp/mop$$
      cp /tmp/mop$$ ${MOPIDCONF}
      rm -f /tmp/mop$$
    }
    # Sync music dir in navidrome.toml
    [ -f "${NAVIDCONF}" ] && {
      nav_music=`grep ^MusicFolder ${NAVIDCONF}`
      nav_music=`echo ${nav_music} | awk ' { print $3 } '`
      nav_music=`echo ${nav_music} | awk ' { print $3 } ' | sed -e "s/\"//g"`
      [ "${exp_music}" == "${nav_music}" ] || {
        cat ${NAVIDCONF} | \
          sed -e "s%^MusicFolder = .*%MusicFolder = \"${exp_music}\"%" > /tmp/nav$$
        cp /tmp/nav$$ ${NAVIDCONF}
        rm -f /tmp/nav$$
      }
    }
    # Sync music dir in yt-dlp.conf
    ytd_music=`grep ^-o ${YTDLPCONF} | grep /Downloads/`
    ytd_music=`echo ${ytd_music} | \
        awk ' { print $2 } ' | \
        sed -e "s%/Downloads/.*$%%"`
    [ "${mpd_music}" == "${ytd_music}" ] || {
      cat ${YTDLPCONF} | \
        sed -e "s%^-o .*/Downloads/%-o ${mpd_music}/Downloads/%" > /tmp/ytd$$
      cp /tmp/ytd$$ ${YTDLPCONF}
      rm -f /tmp/ytd$$
    }

    # Disable and stop any system-wide MPD service
    systemctl is-enabled --quiet mpd.service
    [ $? -eq 0 ] && {
      sudo systemctl disable --quiet mpd.service
      sudo systemctl --user --global disable mpd.service
    }
    systemctl is-enabled --quiet mpd.socket
    [ $? -eq 0 ] && {
      sudo systemctl disable --quiet mpd.socket
      sudo systemctl --user --global disable mpd.socket
    }
    systemctl is-active --quiet mpd.service
    [ $? -eq 0 ] && sudo systemctl stop --quiet mpd.service
    systemctl is-active --quiet mpd.socket
    [ $? -eq 0 ] && sudo systemctl stop --quiet mpd.socket

    systemctl --user daemon-reload --quiet
    # Enable and activate the MPD user service
    systemctl --user is-active --quiet mpd.service
    [ $? -eq 0 ] || systemctl --user start --quiet mpd.service
    systemctl --user is-enabled --quiet mpd.service
    [ $? -eq 0 ] || systemctl --user enable --quiet mpd.service
    have_mpc=`type -p mpc`
    [ "${have_mpc}" ] && mpc update --quiet

    # Enable and activate the MPDstats user service
    systemctl --user is-active --quiet mpdstats.service
    [ $? -eq 0 ] || systemctl --user start --quiet mpdstats.service
    systemctl --user is-enabled --quiet mpdstats.service
    [ $? -eq 0 ] || systemctl --user enable --quiet mpdstats.service

    # Enable and activate the Beets web plugin user service
    systemctl --user is-active --quiet webplugin.service
    [ $? -eq 0 ] || systemctl --user start --quiet webplugin.service
    systemctl --user is-enabled --quiet webplugin.service
    [ $? -eq 0 ] || systemctl --user enable --quiet webplugin.service
  else
    echo "WARNING:"
    echo "Could not detect any music_directory setting in ${MPDCONF}"
    echo "Manual configuration of ${MPDCONF} and ${HOME}/${MPCDIR}/config required"
  fi
}

function check_py_version
{
  # Full version number e.g. 2.7.1
  python_version="$(echo "$($1 -V 2>&1)" | sed -e "s/^.* \(.*\)$/\\1/g")"

  # Return (the first letter -lt "3")
  ! [ "$(echo $python_version | head -c 1 )" -lt "3" ]
}

init_warn() {
  printf "\nMusicPlayerPlus is not yet initialized."
  printf "\nInitialize with ${BOLD}mppinit${NORM} prior to running "
  printf "${BOLD}mppinit $1${NORM}\n"
  printf "\nExiting."
  usage
}

visit_wiki() {
  printf "\nVisit the MusicPlayerPlus Wiki at:"
  printf "\n\t${BOLD}https://github.com/doctorfree/MusicPlayerPlus/wiki${NORM}\n"
}

PYTHON=""
POTENTIAL_BINARIES=( "python" "python3" "python3.6" "python3.5" "python3.7" "python3.4" "python3.3" "python3.8" "python3.2" "python3.1" )
PY3_SUPPORT=false

for i in "${POTENTIAL_BINARIES[@]}"
do
	PYTHON="$i"

	if  $(check_py_version ${PYTHON}) ;
	then
		PY3_SUPPORT=true
		break
	fi
done

if [ ! ${PY3_SUPPORT} ]
then
	echo "[ERROR] Could not find python3 binary, please add it to your \$PATH before continuing"
	exit
fi

# User needs to be in group adm for some systemctl actions
# This is performed in this way to avoid password prompts and subshells
id -nG | grep -qw adm || {
  sudo usermod -aG adm `id -un`
  exec sg adm newgrp `id -gn`
}

# User should not be root. Prompt to proceed if root user
iamroot=
if [ "${EUID}" ]
then
  [ ${EUID} -eq 0 ] && iamroot=1
else
  uid=`id -u`
  [ ${uid} -eq 0 ] && iamroot=1
fi

[ "${iamroot}" ] && {
  printf "\nThe ${BOLD}mppinit${NORM} command should be run as a normal user."
  printf "\nIt appears it has been invoked with 'root' user privileges.\n\n"
  while true
  do
    read -p "Do you intend to use MusicPlayerPlus as the 'root' user ? (y/n) " yn
    case $yn in
        [Yy]* )
                break
                ;;
        [Nn]* )
                printf "\nRe-run this command as a normal user."
                printf "\nExiting.\n\n"
                exit 0
                ;;
            * ) echo "Please answer yes or no."
                ;;
    esac
  done
}

[ -f ${CONFDIR}/config ] || {
    echo "${CONFDIR}/config does not exist."
    echo "MusicPlayerPlus installation incomplete"
    exit 1
}
[ -f ${CONFDIR}/bindings ] || {
    echo "${CONFDIR}/bindings does not exist."
    echo "MusicPlayerPlus installation incomplete"
    exit 1
}

if [ -f ${CONF}/mpcplus/config ]
then
  MPCDIR=".config/mpcplus"
  initialized=1
else
  if [ -f ${HOME}/.mpcplus/config ]
  then
    MPCDIR=".mpcplus"
    initialized=1
  else
    [ -d ${CONF}/mpcplus ] || mkdir -p ${CONF}/mpcplus
    cp ${CONFDIR}/config ${CONF}/mpcplus/config
    MPCDIR=".config/mpcplus"
    initialized=
  fi
fi

acbrainz=
essentia=1
overwrite=
proceed=
remove=
upgrade=1
quiet=
beetsdev=
have_bliss=`type -p blissify`
while getopts "abdeoqrUyu" flag; do
    case $flag in
        a)
            acbrainz=1
            essentia=
            ;;
        b)
            if [ "${have_bliss}" ]
            then
              essentia=
              acbrainz=
            else
              echo "Blissify unavailable. Using Essentia."
              essentia=1
              acbrainz=
            fi
            ;;
        d)
            beetsdev=1
            ;;
        e)
            essentia=1
            acbrainz=
            ;;
        o)
            overwrite=1
            ;;
        q)
            quiet=1
            ;;
        r)
            remove=1
            ;;
        U)
            upgrade=
            ;;
        y)
            proceed=1
            ;;
        u)
            usage
            ;;
    esac
done
shift $(( OPTIND - 1 ))

[ "${essentia}" ] && [ "${acbrainz}" ] && {
  printf "\nOnly one of '-a' and '-e' can be specified."
  printf "\nExiting."
  usage
}

[ "$1" == "sync" ] && {
  if [ "${initialized}" ]
  then
    printf "\nSyncing MusicPlayerPlus music directory, please wait ..."
    sync_music_dir
    printf "\n\nMusicPlayerPlus music directory synchronized.\n"
  else
    init_warn sync
  fi
  exit 0
}

[ "$1" == "bandcamp" ] && {
  if [ "${initialized}" ]
  then
    printf "\nDownloading albums in your Bandcamp collections"
    printf "\nA Bandcamp username must be configured in:"
    printf "\n\t${CALIPCONF}\n\n"
    [ "${proceed}" ] || {
      while true
      do
        read -p "My Bandcamp username is configured, proceed with download ? (y/n) " yn
        case $yn in
          [Yy]* )
            break
            ;;
          [Nn]* )
            printf "\nBandcamp collections download can be performed with:"
            printf "\n\t${CCPTDIR}/bandcamp-download"
            printf "\n\nExiting.\n\n"
            exit 0
            ;;
          * ) echo "Please answer yes or no."
            ;;
        esac
      done
    }
    if [ -x ${CCPTDIR}/bandcamp-download ]
    then
      printf "\n\tInvoking Bandcamp collections download script\n"
      ${CCPTDIR}/bandcamp-download
    else
      printf "\nBandcamp collections download script "
      printf "${CCPTDIR}/bandcamp-download"
      printf "\nis not found or not executable. No download performed.\n"
    fi
    printf "\nImport the music library into the Beets media management system:"
    printf "\n\t${BOLD}mppinit import${NORM}"
    printf "\nAfter the import has completed, perform an update of the Beets"
    printf "\nlibrary metadata, genres, and album cover art:"
    printf "\n\t${BOLD}mppinit metadata${NORM}"
    printf "\nActivate the YAMS Last.fm scrobbler:"
    printf "\n\t${BOLD}mppinit yams${NORM}\n"
    visit_wiki
  else
    init_warn bandcamp
  fi
  exit 0
}

[ "$1" == "soundcloud" ] && {
  if [ "${initialized}" ]
  then
    printf "\nDownloading favorites in your Soundcloud account\n"
    if [ -x ${SCPTDIR}/soundcloud-download ]
    then
      ${SCPTDIR}/soundcloud-download
    else
      printf "\nSoundcloud favorites download script "
      printf "${SCPTDIR}/soundcloud-download"
      printf "\nis not found or not executable. No download performed.\n"
    fi
    printf "\nImport the music library into the Beets media management system:"
    printf "\n\t${BOLD}mppinit import${NORM}"
    printf "\nAfter the import has completed, perform an update of the Beets"
    printf "\nlibrary metadata, genres, and album cover art:"
    printf "\n\t${BOLD}mppinit metadata${NORM}"
    printf "\nActivate the YAMS Last.fm scrobbler:"
    printf "\n\t${BOLD}mppinit yams${NORM}\n"
    visit_wiki
  else
    init_warn soundcloud
  fi
  exit 0
}

[ "$1" == "import" ] && {
  if [ "${initialized}" ]
  then
    set_music_dir
    num_wav=`find "${exp_music}" -type f -name \*\.wav | wc -l`
    num_m4a=`find "${exp_music}" -type f -name \*\.m4a | wc -l`
    num_all=`find "${exp_music}" -type f | wc -l`
    [ ${num_wav} -gt 0 ] || [ ${num_m4a} -gt 0 ] && {
      printf "\nConverting WAV format media to MP3 format\n\tand"
    }
    printf "\nPerforming Beets media library management import"
    printf "\n\nThis process may take hours depending on the library size.\n"
    [ ${num_wav} -gt 0 ] && {
      printf "\n\t- Identified ${num_wav} WAV format files in library"
    }
    [ ${num_m4a} -gt 0 ] && {
      printf "\n\t- Identified ${num_m4a} M4A format files in library"
    }
    printf "\n\t- Identified ${num_all} total files in library\n\n"
    [ "${proceed}" ] || {
      while true
      do
        read -p "Proceed with this potentially long process ? (y/n) " yn
        case $yn in
          [Yy]* )
            break
            ;;
          [Nn]* )
            printf "\nImport initialization steps can be performed individually:"
            printf "\n\tmpplus -F    # Convert WAV format media to MP3"
            printf "\n\tmpplus -G    # Convert M4A format media to MP3"
            printf "\n\tmpplus -I    # Import media library into Beets"
            printf "\n\nExiting.\n\n"
            exit 0
            ;;
          * ) echo "Please answer yes or no."
            ;;
        esac
      done
    }
    [ ${num_wav} -gt 0 ] || [ ${num_m4a} -gt 0 ] && {
      printf "\n\tConverting WAV format media to MP3 format media\n"
      mpplus -F > /dev/null 2>&1
    }
    printf "\n\tImporting music library into Beets media management system\n"
    mpplus -I
    printf "\nAfter the Beets Import is complete, update metadata and perform"
    printf "\nacoustic analysis and extraction with Essentia by executing:"
    printf "\n\t${BOLD}mppinit metadata${NORM}\n"
    printf "\nAlternatively, to use AcousticBrainz for metadata retrieval:"
    printf "\n\t${BOLD}mppinit -a metadata${NORM}\n"
    [ "${have_bliss}" ] && {
      printf "\nTo use Blissify for acoustic metadata analysis:"
      printf "\n\t${BOLD}mppinit -b metadata${NORM}\n"
    }
    printf "\nActivate the YAMS Last.fm scrobbler with the command:"
    printf "\n\t${BOLD}mppinit yams${NORM}\n"
    visit_wiki
  else
    init_warn import
  fi
  exit 0
}

[ "$1" == "metadata" ] && {
  if [ "${initialized}" ]
  then
    printf "\nPerforming Beets Media Library Metadata Retrieval"
    printf "\n\nThis process may take hours depending on the library size."
    printf "\nNotifications of each step will be provided."
    printf "\nThe steps performed include:"
    printf "\n\t- Identify and delete duplicate tracks"
    printf "\n\t- Retrieve album genres"
    printf "\n\t- Download album cover art"
    if [ "${essentia}" ]
    then
      printf "\n\t- Analyze and extract acoustic information with Essentia\n\n"
    else
      if [ "${acbrainz}" ]
      then
        printf "\n\t- Retrieve acoustic information with AcousticBrainz\n\n"
      else
        printf "\n\t- Analyze acoustic information with Blissify\n\n"
      fi
    fi
    [ "${proceed}" ] || {
      while true
      do
        read -p "Proceed with this potentially long process ? (y/n) " yn
        case $yn in
          [Yy]* )
            break
            ;;
          [Nn]* )
            printf "\nMetadata initialization steps can be performed individually:"
            printf "\n\tbeet duplicates -d"
            printf "\n\tbeet move"
            printf "\n\tbeet lastgenre"
            printf "\n\tmpplus -D art"
            if [ "${essentia}" ]
            then
              printf "\n\tmpplus -X all"
            else
              if [ "${acbrainz}" ]
              then
                printf "\n\tmpplus -x all"
              else
                printf "\n\tmpplus -B"
              fi
            fi
            printf "\nExiting.\n\n"
            exit 0
            ;;
          * ) echo "Please answer yes or no."
            ;;
        esac
      done
    }
    [ -d ${BEETSLOGDIR} ] || mkdir -p ${BEETSLOGDIR}
    DUP_LOG="${BEETSLOGDIR}/duplicates.log"
    printf "\n\tRemoving duplicate tracks in music library"
    printf "\n\tMonitor this potentially long process with:"
    printf "\n\t\ttail -f ${DUP_LOG}\n"
    echo "# Starting duplicate track identification and removal" >> "${DUP_LOG}"
    START_SECONDS=$(date +%s)
    beet -v duplicates -d >> "${DUP_LOG}" 2>&1
    echo "# Completed duplicate track identification and removal" >> "${DUP_LOG}"
    FINISH_SECONDS=$(date +%s)
    ELAPSECS=$(( FINISH_SECONDS - START_SECONDS ))
    ELAPSED=`eval "echo total elapsed time: $(date -ud "@$ELAPSECS" +'$((%s/3600/24)) days %H hr %M min %S sec')"`
    printf "\n# Duplicates ${ELAPSED}\n" >> "${DUP_LOG}"

    MOV_LOG="${BEETSLOGDIR}/move.log"
    printf "\n\tRenaming tracks that were duplicates"
    printf "\n\tMonitor this process with:"
    printf "\n\t\ttail -f ${MOV_LOG}\n"
    echo "# Starting track renaming" >> "${MOV_LOG}"
    START_SECONDS=$(date +%s)
    beet -v move >> "${MOV_LOG}" 2>&1
    echo "# Completed track renaming" >> "${MOV_LOG}"
    FINISH_SECONDS=$(date +%s)
    ELAPSECS=$(( FINISH_SECONDS - START_SECONDS ))
    ELAPSED=`eval "echo total elapsed time: $(date -ud "@$ELAPSECS" +'$((%s/3600/24)) days %H hr %M min %S sec')"`
    printf "\n# Renaming ${ELAPSED}\n" >> "${MOV_LOG}"

    GEN_LOG="${BEETSLOGDIR}/lastgenre.log"
    printf "\n\tRetrieving genre from Last.fm"
    printf "\n\tMonitor this process with:"
    printf "\n\t\ttail -f ${GEN_LOG}\n"
    echo "# Starting genre retrieval" >> "${GEN_LOG}"
    START_SECONDS=$(date +%s)
    beet -v lastgenre >> "${GEN_LOG}" 2>&1
    echo "# Completed genre retrieval" >> "${GEN_LOG}"
    FINISH_SECONDS=$(date +%s)
    ELAPSECS=$(( FINISH_SECONDS - START_SECONDS ))
    ELAPSED=`eval "echo total elapsed time: $(date -ud "@$ELAPSECS" +'$((%s/3600/24)) days %H hr %M min %S sec')"`
    printf "\n# Genre retrieval ${ELAPSED}\n" >> "${GEN_LOG}"

    printf "\n\tDownloading album cover art\n\n"
    mpplus -D art > /dev/null 2>&1
    [ "${proceed}" ] || {
      while true
      do
        read -p "Retrieve acoustic information for all tracks (possibly long) ? (y/n) " yn
        case $yn in
          [Yy]* )
            break
            ;;
          [Nn]* )
            printf "\nAcoustic information not analyzed or retrieved."
            printf "\nAcoustic information can be retrieved with the command:\n"
            if [ "${essentia}" ]
            then
              printf "\n\tmpplus -X all"
            else
              if [ "${acbrainz}" ]
              then
                printf "\n\tmpplus -x all"
              else
                printf "\n\tmpplus -B"
              fi
            fi
            printf "\n\nMusicPlayerPlus Metadata Retrieval Complete.\n"
            exit 0
            ;;
          * ) echo "Please answer yes or no."
            ;;
        esac
      done
    }
    if [ "${essentia}" ]
    then
      printf "\n\tRetrieving acoustic information with Beets Xtractor plugin\n"
      mpplus -X all
    else
      if [ "${acbrainz}" ]
      then
        printf "\n\tRetrieving acoustic information with AcousticBrainz plugin\n"
        mpplus -x all
      else
        printf "\n\tRetrieving acoustic information with Blissify\n"
        mpplus -B
      fi
    fi
    printf "\nMusicPlayerPlus Metadata Retrieval In Progress.\n"
    printf "\nActivate the YAMS Last.fm scrobbler with the command:"
    printf "\n\t${BOLD}mpplus -Y${NORM}\n"
    visit_wiki
  else
    init_warn metadata
  fi
  exit 0
}

init_navidrome() {
  user=`id -u`
  group=`id -g`
  navivar="/var/lib/navidrome"
  arch=`uname -m`

  if [ -x /opt/navidrome/navidrome ]
  then
    echo "Existing Navidrome installation detected. Skipping Navidrome install."
  else
    sudo install -d -o ${user} -g ${group} /opt/navidrome
    sudo install -d -o ${user} -g ${group} ${navivar}

    if [ -f "${navivar}/Navidrome.tar.gz" ]
    then
      echo "Found an existing ${navivar}/Navidrome.tar.gz"
      echo "Using the existing Navidrome release download."
      echo "To re-download Navidrome, remove ${navivar}/Navidrome.tar.gz"
      echo "and re-run the 'mppinit navidrome' command."
    else
      wget -q https://github.com/navidrome/navidrome/releases/download/v${navi_version}/navidrome_${navi_version}_Linux_${arch}.tar.gz -O ${navivar}/Navidrome.tar.gz
    fi

    if [ -f "${navivar}/Navidrome.tar.gz" ]
    then
      sudo tar -xzf ${navivar}/Navidrome.tar.gz -C /opt/navidrome/
      rm -f "${navivar}/Navidrome.tar.gz"
      sudo chown -R ${user} /opt/navidrome
    else
      echo "Navidrome download failed."
      echo "Could not locate ${navivar}/Navidrome.tar.gz"
      echo ""
      echo "Visit https://github.com/navidrome/navidrome/releases/download/"
      echo "and locate the latest Navidrome release for this platform (${arch})."
      echo ""
      echo "Download the Navidrome release 'tar.gz' and move it to:"
      echo "    ${navivar}/Navidrome.tar.gz"
      echo "Then re-run the 'mppinit navidrome' command."
      echo ""
      echo "Exiting without installing or configuring Navidrome."
      exit 1
    fi
  fi
  [ -x /opt/navidrome/navidrome ] && {
    if [ -d "${HOME}/.local/bin" ]
    then
      BINDIR="${HOME}/.local/bin"
      SUDO=
    else
      BINDIR="/usr/bin"
      SUDO=sudo
    fi
    [ -x "${BINDIR}/navidrome" ] || {
      ${SUDO} ln -s /opt/navidrome/navidrome "${BINDIR}/navidrome"
    }
  }

  [ -f "${NAVIDCONF}" ] || {
    [ -f "${MPPCDIR}/navidrome/navidrome.toml" ] && {
      cat "${MPPCDIR}/navidrome/navidrome.toml" | \
          sed -e "s%__HOME__%${HOME}%" > "${NAVIDCONF}"
    }
  }

  # Enable Navidrome service
  systemctl --user is-active navidrome.service >/dev/null 2>&1 || {
    systemctl --user start navidrome.service
  }
  systemctl --user is-enabled navidrome.service >/dev/null 2>&1 || {
    systemctl --user enable navidrome.service
  }
}

remove_navidrome() {
  mppuser=`id -un`
  varuser=$(stat -c '%U' /var/lib/navidrome)
  optuser=$(stat -c '%U' /opt/navidrome)

  [ "${mppuser}" == "${varuser}" ] || {
    echo "The mppinit user: ${mppuser} does now own /var/lib/navidrome"
    echo "Navidrome removal can only be performed by user: ${varuser}"
    echo "Re-run 'mppinit -r navidrome' as user ${varuser}"
    echo "Exiting without removal"
    exit 1
  }
  [ "${mppuser}" == "${optuser}" ] || {
    echo "The mppinit user: ${mppuser} does now own /opt/navidrome"
    echo "Navidrome removal can only be performed by user: ${optuser}"
    echo "However, /var/lib/navidrome and /opt/navidrome are owned by"
    echo "different users indicating Navidrome installation was performed"
    echo "by something other than MusicPlayerPlus. Manually remove"
    echo "Navidrome, removal with mppinit is not supported."
    echo "Exiting without removal"
    exit 1
  }
  # Stop and Disable Navidrome service
  systemctl --user is-active navidrome.service >/dev/null 2>&1 && {
    systemctl --user stop navidrome.service
  }
  systemctl --user is-enabled navidrome.service >/dev/null 2>&1 && {
    systemctl --user disable navidrome.service
  }

  sudo rm -rf /opt/navidrome
  sudo rm -rf /var/lib/navidrome

  if [ -L "${HOME}/.local/bin/navidrome" ]
  then
    BINDIR="${HOME}/.local/bin"
    SUDO=
  else
    BINDIR="/usr/bin"
    SUDO=sudo
  fi
  ${SUDO} rm -f "${BINDIR}/navidrome"
}

[ "$1" == "navidrome" ] && {
  [ "${remove}" ] && {
    printf "\nRemoving Navidrome service.\n\n"
    while true
    do
      read -p "Do you wish to continue with Navidrome removal ? (y/n) " yn
      case $yn in
          [Yy]* )
                break
                ;;
          [Nn]* )
                printf "\nNavidrome removal aborted."
                printf "\nExiting.\n\n"
                exit 0
                ;;
              * ) echo "Please answer yes or no."
                ;;
      esac
    done
    remove_navidrome
    printf "\n${BOLD}Navidrome service removed${NORM}"
    printf "\nTo re-install Navidrome run ${BOLD}'mppinit navidrome'${NORM}\n\n"
    exit 0
  }
  if [ "${initialized}" ]
  then
    if [ "$2" ]
    then
      navi_version="$2"
    else
      navi_version="0.47.5"
    fi
    printf "\nInstalling and configuring Navidrome version ${navi_version}.\n\n"
    while true
    do
      read -p "Do you wish to continue with Navidrome activation ? (y/n) " yn
      case $yn in
          [Yy]* )
                break
                ;;
          [Nn]* )
                printf "\nNavidrome activation aborted."
                printf "\nExiting.\n\n"
                exit 0
                ;;
              * ) echo "Please answer yes or no."
                ;;
      esac
    done
    init_navidrome
  else
    init_warn navidrome
  fi
  printf "\n\n${BOLD}Navidrome service enabled and activated${NORM}"
  printf "\n${BOLD}Visit http://localhost:4533 to get started${NORM}\n"
  exit 0
}

[ "$1" == "mopidy" ] && {
  [ "${remove}" ] && {
    printf "\nRemoving Mopidy service.\n\n"
    while true
    do
      read -p "Do you wish to continue with Mopidy removal ? (y/n) " yn
      case $yn in
          [Yy]* )
                break
                ;;
          [Nn]* )
                printf "\nMopidy removal aborted."
                printf "\nExiting.\n\n"
                exit 0
                ;;
              * ) echo "Please answer yes or no."
                ;;
      esac
    done
    remove_mopidy
    printf "\n${BOLD}Mopidy service removed${NORM}"
    printf "\nTo re-install Mopidy run ${BOLD}'mppinit mopidy'${NORM}\n\n"
    exit 0
  }
  if [ "${initialized}" ]
  then
    printf "\nInstalling, configuring, and activating Mopidy music server."
    printf "\nThis will deactivate MPD. However, configured Mopidy extensions"
    printf "\nwill continue to support MusicPlayerPlus MPD clients, Beets,"
    printf "\nand local music library search, organization, and playback.\n\n"
    while true
    do
      read -p "Do you wish to continue with Mopidy activation ? (y/n) " yn
      case $yn in
          [Yy]* )
                break
                ;;
          [Nn]* )
                printf "\nMopidy activation aborted."
                printf "\nExiting.\n\n"
                exit 0
                ;;
              * ) echo "Please answer yes or no."
                ;;
      esac
    done
    init_mopidy
  else
    init_warn mopidy
  fi
  get_ip
  printf "\n\n${BOLD}Mopidy services enabled and activated${NORM}"
  printf "\n${BOLD}MPD services deactivated${NORM}"
  printf "\n${BOLD}Visit http://${IP}:6680 to get started${NORM}\n"
  exit 0
}

[ "$1" == "mpd" ] && {
  if [ "${initialized}" ]
  then
    m_enabled=
    m_active=
    systemctl --user is-enabled mopidy.service >/dev/null 2>&1 && m_enabled=1
    systemctl --user is-active mopidy.service >/dev/null 2>&1 && m_active=1
    printf "\nActivating the Music Player Daemon (MPD) music server."
    [ "${m_enabled}" ] || [ "${m_active}" ] && {
      printf "\nThis will deactivate Mopidy and Mopidy extensions.\n\n"
      while true
      do
        read -p "Do you wish to continue with MPD activation ? (y/n) " yn
        case $yn in
          [Yy]* )
                break
                ;;
          [Nn]* )
                printf "\nMPD activation aborted."
                printf "\nExiting.\n\n"
                exit 0
                ;;
              * ) echo "Please answer yes or no."
                ;;
        esac
      done
    }
    [ "${m_enabled}" ] && {
      systemctl --user disable mopidy.service
    }
    [ "${m_active}" ] && {
      systemctl --user stop mopidy.service
    }

    # Reconfigure mpcplus with MPD visualizer data source
    [ -x ${SCPTDIR}/viz_data_src.sh ] && ${SCPTDIR}/viz_data_src.sh mpd

    systemctl --user is-active mpd.service >/dev/null 2>&1 || {
      systemctl --user start mpd.service
    }
    systemctl --user is-enabled mpd.service >/dev/null 2>&1 || {
      systemctl --user enable mpd.service
    }
    [ -f ${HOME}/.config/systemd/user/mpdstats.service ] && {
      systemctl --user is-active mpdstats.service >/dev/null 2>&1 || {
        systemctl --user start mpdstats.service
      }
      systemctl --user is-enabled mpdstats.service >/dev/null 2>&1 || {
        systemctl --user enable mpdstats.service
      }
    }
    [ -f ${HOME}/.config/systemd/user/yams.service ] && {
      systemctl --user is-active yams.service >/dev/null 2>&1 || {
        systemctl --user start yams.service
      }
      systemctl --user is-enabled yams.service >/dev/null 2>&1 || {
        systemctl --user enable yams.service
      }
    }
  else
    init_warn mpd
  fi
  if [ "${m_enabled}" ] || [ "${m_active}" ]
  then
    printf "\n\n${BOLD}Mopidy deactivated, MPD services enabled and activated${NORM}\n"
  else
    printf "\n\n${BOLD}MPD services enabled and activated${NORM}\n"
  fi
  exit 0
}

[ "$1" == "profiles" ] && {
  create_profiles
  exit 0
}

[ "$1" == "yams" ] && {
  if [ "${initialized}" ]
  then
    mpplus -Y
    visit_wiki
  else
    init_warn yams
  fi
  exit 0
}

[ ${initialized} ] && {
  [ "${proceed}" ] || {
    [ "${overwrite}" ] || {
      printf "\nMusicPlayerPlus initialization has previously been performed"
      printf "\nand there is an existing MusicPlayerPlus configuration.\n\n"
      while true
      do
        read -p "Preserve existing, Overwrite existing, Skip ? (p/o/s) " pos
        case $pos in
          [Pp]* )
            break
            ;;
          [Oo]* )
            overwrite=1
            break
            ;;
          [Ss]* )
            printf "\nExiting.\n\n"
            exit 0
            ;;
          * ) echo "Please answer 'p', 'o', or 's'."
            ;;
        esac
      done
    }
  }
}

printf "\nInitializing MusicPlayerPlus, please wait ..."
[ "${quiet}" ] || {
  printf "\n\tInstalling configuration files in $CONF ..."
}
if [ -f ${HOME}/${MPCDIR}/bindings ]
then
  [ "${overwrite}" ] && cp ${CONFDIR}/bindings ${HOME}/${MPCDIR}/bindings
else
  cp ${CONFDIR}/bindings ${HOME}/${MPCDIR}/bindings
fi

for cfg in ${CFGS}
do
  if [ -f ${HOME}/${MPCDIR}/${cfg} ]
  then
    [ "${overwrite}" ] && cp ${CONFDIR}/${cfg} ${HOME}/${MPCDIR}/${cfg}
  else
    cp ${CONFDIR}/${cfg} ${HOME}/${MPCDIR}/${cfg}
  fi
  chmod 644 ${HOME}/${MPCDIR}/${cfg}
done
for scp in ${SCPS}
do
  if [ -f ${HOME}/${MPCDIR}/${scp} ]
  then
    [ "${overwrite}" ] && cp ${SCPTDIR}/${scp} ${HOME}/${MPCDIR}/${scp}
  else
    cp ${SCPTDIR}/${scp} ${HOME}/${MPCDIR}/${scp}
  fi
  chmod 755 ${HOME}/${MPCDIR}/${scp}
done

[ -d ${CONF}/mppcava ] || mkdir -p ${CONF}/mppcava
if [ -f ${CONF}/mppcava/config ]
then
  [ "${overwrite}" ] && cp ${MPPCDIR}/mppcava/config ${CONF}/mppcava/config
else
  cp ${MPPCDIR}/mppcava/config ${CONF}/mppcava/config
fi
if [ -f ${CONF}/mppcava/config-tmux ]
then
  [ "${overwrite}" ] && {
    cp ${MPPCDIR}/mppcava/config-tmux ${CONF}/mppcava/config-tmux
  }
else
  cp ${MPPCDIR}/mppcava/config-tmux ${CONF}/mppcava/config-tmux
fi

if [ -d ${CONF}/tmuxp ]
then
  for tmc in ${MPPCDIR}/tmuxp/*
  do
    tmcbase=`basename "${tmc}"`
    if [ -d "${tmc}" ]
    then
      [ -d "${CONF}/tmuxp/${tmcbase}" ] || {
        cp -a "${tmc}" "${CONF}/tmuxp/${tmcbase}"
      }
    else
      if [ -f "${CONF}/tmuxp/${tmcbase}" ]
      then
        [ "${overwrite}" ] && cp "${tmc}" "${CONF}/tmuxp/${tmcbase}"
      else
        cp "${tmc}" "${CONF}/tmuxp/${tmcbase}"
      fi
    fi
  done
else
  cp -a ${MPPCDIR}/tmuxp ${CONF}/tmuxp
fi

create_profiles

[ "${quiet}" ] || {
  printf "\n\tInstalling MPD configuration in ${MPDCONFDIR} ..."
}
# If there is no user MPD config
# then copy the MusicPlayerPlus MPD config folder
# into the user's home and setup user MPD service
if [ -f ${MPDCONF} ]
then
  [ "${overwrite}" ] && cp ${MPPCDIR}/mpd/mpd.conf ${MPDCONF}
else
  if [ -d ${MPDCONFDIR} ]
  then
    cp ${MPPCDIR}/mpd/mpd.conf ${MPDCONF}
  else
    cp -a ${MPPCDIR}/mpd ${MPDCONFDIR}
  fi
fi

[ "${quiet}" ] || {
  printf "\n\tInstalling Beets configuration in ${BEETSCONFDIR} ..."
}
# If there is no user beets config.yaml and genres folder then
# copy the MusicPlayerPlus beets config.yaml and genres folder
# into the user's home and setup user mpdstats service
if [ -f ${BEETSCONF} ]
then
  [ "${overwrite}" ] && cp ${MPPCDIR}/beets/config.yaml ${BEETSCONF}
else
  [ -d ${BEETSCONFDIR} ] || mkdir -p ${BEETSCONFDIR}
  cp ${MPPCDIR}/beets/config.yaml ${BEETSCONF}
fi
if [ -d ${BEETSGENR} ]
then
  for genconf in genres-tree.yaml genres.txt
  do
    if [ -f ${BEETSGENR}/${genconf} ]
    then
      [ "${overwrite}" ] && {
        cp ${MPPCDIR}/beets/genres/${genconf} ${BEETSGENR}/${genconf}
      }
    else
      cp ${MPPCDIR}/beets/genres/${genconf} ${BEETSGENR}/${genconf}
    fi
  done
else
  cp -a ${MPPCDIR}/beets/genres ${BEETSGENR}
fi

[ -d ${BEETSCONFDIR}/xtraction_data ] || mkdir -p ${BEETSCONFDIR}/xtraction_data
[ -d ${BEETSLOGDIR} ] || mkdir -p ${BEETSLOGDIR}

[ "${quiet}" ] || {
  printf "\n\tInstalling Calliope configuration in ${CALIPCONFDIR} ..."
}
# If there is no user calliope config folder then copy the
# MusicPlayerPlus calliope config folder into the user's home
if [ -f ${CALIPCONF} ]
then
  [ "${overwrite}" ] && cp ${MPPCDIR}/calliope/calliope.conf ${CALIPCONFDIR}
else
  if [ -d ${CALIPCONFDIR} ]
  then
    cp ${MPPCDIR}/calliope/calliope.conf ${CALIPCONFDIR}
  else
    cp -a ${MPPCDIR}/calliope ${CALIPCONFDIR}
  fi
fi

[ "${quiet}" ] || {
  printf "\n\tInstalling Kitty configuration in ${KITTYCONFDIR} ..."
}
# If there is no user kitty config folder then copy the
# MusicPlayerPlus kitty config folder into the user's home
if [ -d ${KITTYCONFDIR} ]
then
  if [ "${overwrite}" ]
  then
    cp -a ${MPPCDIR}/kitty ${CONF}
  else
    cp -an ${MPPCDIR}/kitty ${CONF}
  fi
else
  cp -a ${MPPCDIR}/kitty ${KITTYCONFDIR}
fi
[ -f ${KITTYCONFDIR}/kitty.conf ] || cp ${KITTYCONF} ${KITTYCONFDIR}/kitty.conf

[ "${quiet}" ] || {
  printf "\n\tInstalling Mopidy configuration in ${MOPIDCONFDIR} ..."
}
# If there is no user Mopidy config folder then copy the
# MusicPlayerPlus Mopidy config folder into the user's home
if [ -f ${MOPIDCONF} ]
then
  [ "${overwrite}" ] && cp ${MPPCDIR}/mopidy/mopidy.conf ${MOPIDCONFDIR}
else
  [ -d ${MOPIDCONFDIR} ] || mkdir -p ${MOPIDCONFDIR}
  cp ${MPPCDIR}/mopidy/mopidy.conf ${MOPIDCONFDIR}
fi
[ -d ${MOPIDCONFDIR}/cache ] || mkdir -p ${MOPIDCONFDIR}/cache
[ -d ${MOPIDCONFDIR}/data ] || mkdir -p ${MOPIDCONFDIR}/data

[ "${quiet}" ] || {
  printf "\n\tInstalling Navidrome configuration in ${NAVIDCONFDIR} ..."
}
# If there is no user Navidrome config folder then copy the
# MusicPlayerPlus Navidrome config folder into the user's home
if [ -f "${NAVIDCONF}" ]
then
  [ "${overwrite}" ] && {
    cat "${MPPCDIR}/navidrome/navidrome.toml" | \
        sed -e "s%__HOME__%${HOME}%" > "${NAVIDCONF}"
  }
else
  [ -d ${NAVIDCONFDIR} ] || mkdir -p ${NAVIDCONFDIR}
  cat "${MPPCDIR}/navidrome/navidrome.toml" | \
      sed -e "s%__HOME__%${HOME}%" > "${NAVIDCONF}"
fi

[ "${quiet}" ] || {
  printf "\n\tInstalling yt-dlp configuration in ${YTDLPCONFDIR} ..."
}
# If there is no user yt-dlp config folder then copy the
# MusicPlayerPlus yt-dlp config folder into the user's home
if [ -f ${YTDLPCONF} ]
then
  [ "${overwrite}" ] && cp ${MPPCDIR}/yt-dlp/config ${YTDLPCONFDIR}
else
  if [ -d ${YTDLPCONFDIR} ]
  then
    cp ${MPPCDIR}/yt-dlp/config ${YTDLPCONFDIR}
  else
    cp -a ${MPPCDIR}/yt-dlp ${YTDLPCONFDIR}
  fi
fi

SYSTEMDIR="${CONF}/systemd/user"
MPDSTATSD="${SYSTEMDIR}/mpdstats.service"
MOPSTATSD="${SYSTEMDIR}/mopidy.service"
NAVSTATSD="${SYSTEMDIR}/navidrome.service"
WEBPLUGSD="${SYSTEMDIR}/webplugin.service"
YAMSTATSD="${SYSTEMDIR}/yams.service"
[ "${quiet}" ] || {
  printf "\n\tSetting up user system services in ${SYSTEMDIR} ..."
}
if [ -f ${MPDSTATSD} ]
then
  [ "${overwrite}" ] && cp ${MPPCDIR}/beets/mpdstats.service ${MPDSTATSD}
else
  [ -d ${SYSTEMDIR} ] || mkdir -p ${SYSTEMDIR}
  cp ${MPPCDIR}/beets/mpdstats.service ${MPDSTATSD}
fi
if [ -f ${WEBPLUGSD} ]
then
  [ "${overwrite}" ] && cp ${MPPCDIR}/beets/webplugin.service ${WEBPLUGSD}
else
  [ -d ${SYSTEMDIR} ] || mkdir -p ${SYSTEMDIR}
  cp ${MPPCDIR}/beets/webplugin.service ${WEBPLUGSD}
fi
if [ -f ${MOPSTATSD} ]
then
  [ "${overwrite}" ] && cp ${MPPCDIR}/mopidy/mopidy.service ${MOPSTATSD}
else
  [ -d ${SYSTEMDIR} ] || mkdir -p ${SYSTEMDIR}
  cp ${MPPCDIR}/mopidy/mopidy.service ${MOPSTATSD}
fi
if [ -f ${NAVSTATSD} ]
then
  [ "${overwrite}" ] && cp ${MPPCDIR}/navidrome/navidrome.service ${NAVSTATSD}
else
  [ -d ${SYSTEMDIR} ] || mkdir -p ${SYSTEMDIR}
  cp ${MPPCDIR}/navidrome/navidrome.service ${NAVSTATSD}
fi
if [ -f ${YAMSTATSD} ]
then
  [ "${overwrite}" ] && cp ${MPPCDIR}/mpd/yams.service ${YAMSTATSD}
else
  [ -d ${SYSTEMDIR} ] || mkdir -p ${SYSTEMDIR}
  cp ${MPPCDIR}/mpd/yams.service ${YAMSTATSD}
fi

[ "${quiet}" ] || {
  printf "\n\tSetting HOME in configuration files ..."
}
FIFS="mppcava/config-tmux mppcava/config"
for cnf in ${FIFS}
do
  [ -f ${CONF}/${cnf} ] && {
    cat ${CONF}/${cnf} | sed -e "s#/home/USERNAME#$HOME#" > /tmp/cnf$$
    cp /tmp/cnf$$ ${CONF}/${cnf}
    rm -f /tmp/cnf$$
  }
done

[ "${quiet}" ] || {
  printf "\n\tSetting up default tmux configuration ..."
}
# Setup default tmux configuration for this user
[ -f ${MPPCDIR}/tmux.conf ] && {
  if [ -f ${HOME}/.tmux.conf ]
  then
    diff -u -B <(grep -vE '^\s*(#|$)' ${MPPCDIR}/tmux.conf)  <(grep -vE '^\s*(#|$)' ${HOME}/.tmux.conf) > /dev/null || {
      echo ""
      echo "MusicPlayerPlus includes extensive configuration for tmux."
      echo "An existing $HOME/.tmux.conf has been detected."
      echo "In order to enable many MusicPlayerPlus tmux features,"
      echo "it is necessary to install a customized $HOME/.tmux.conf."
      echo ""
      if [ "${proceed}" ]
      then
        if [ "${overwrite}" ]
        then
          cp ${MPPCDIR}/tmux.conf ${HOME}/.tmux.conf
          echo ""
          echo "MusicPlayerPlus tmux configurations are applied"
          echo "The file ${MPPCDIR}/tmux.conf"
          echo "was copied to $HOME/.tmux.conf"
        else
          cat ${MPPCDIR}/tmux.conf >> ${HOME}/.tmux.conf
          echo ""
          echo "MusicPlayerPlus tmux configurations are applied"
          echo "The file ${MPPCDIR}/tmux.conf"
          echo "was appended to $HOME/.tmux.conf"
          echo "The MusicPlayerPlus additions follow the comment 'MusicPlayerPlus'"
          echo "Please review these changes and customize as needed"
        fi
      else
        if [ "${overwrite}" ]
        then
          cp ${MPPCDIR}/tmux.conf ${HOME}/.tmux.conf
          echo ""
          echo "MusicPlayerPlus tmux configurations are applied"
          echo "The file ${MPPCDIR}/tmux.conf"
          echo "was copied to $HOME/.tmux.conf"
        else
          echo "Please answer if you would like to:"
          printf "\n\t[A]ppend customization"
          printf "\n\t[B]ackup and customize"
          printf "\n\t[O]verwrite existing"
          printf "\n\t[S]kip customization\n"
          echo "Answer 'a', 'b', 'o', or 's'"
          echo ""
          while true
          do
            read -p "Append/Backup/Overwrite/Skip tmux configuration? (a/b/o/s) " customize
            case $customize in
              [Aa]* )
                cat ${MPPCDIR}/tmux.conf >> ${HOME}/.tmux.conf
                echo ""
                echo "MusicPlayerPlus tmux configurations are applied"
                echo "The file ${MPPCDIR}/tmux.conf"
                echo "was appended to $HOME/.tmux.conf"
                echo "The MusicPlayerPlus additions follow the comment 'MusicPlayerPlus'"
                echo "Please review these changes and customize as needed"
                break
                ;;
              [Bb]* )
                cp ${HOME}/.tmux.conf ${HOME}/.tmux.conf.bak$$
                cp ${MPPCDIR}/tmux.conf ${HOME}/.tmux.conf
                echo ""
                echo "MusicPlayerPlus tmux configurations are applied"
                echo "The file ${MPPCDIR}/tmux.conf"
                echo "was copied to $HOME/.tmux.conf"
                echo "A backup of the previous file was created at $HOME/.tmux.conf.bak$$"
                break
                ;;
              [Oo]* )
                cp ${MPPCDIR}/tmux.conf ${HOME}/.tmux.conf
                echo ""
                echo "MusicPlayerPlus tmux configurations are applied"
                echo "The file ${MPPCDIR}/tmux.conf"
                echo "was copied to $HOME/.tmux.conf"
                break
                ;;
              [Ss]* )
                echo ""
                echo "MusicPlayerPlus tmux configurations have not been applied"
                echo "The file $HOME/.tmux.conf remains unmodified"
                echo "Some MusicPlayerPlus features will not work properly with tmux"
                echo ""
                echo "The file ${MPPCDIR}/tmux.conf"
                echo "contains the MusicPlayerPlus tmux customizations."
                echo "To fully enable MusicPlayerPlus tmux features, merge"
                echo "${MPPCDIR}/tmux.conf with $HOME/.tmux.conf"
                break
                ;;
              * )
                echo "Please answer 'a', 'b', 'o', or 's'"
                ;;
            esac
          done
        fi
      fi
    }
  else
    cp ${MPPCDIR}/tmux.conf ${HOME}/.tmux.conf
  fi
}

have_git=`type -p git`
TPM="${HOME}/.tmux/plugins/tpm"
[ -d ${TPM} ] || {
  [ "${have_git}" ] && {
    git clone https://github.com/tmux-plugins/tpm ${TPM} > /dev/null 2>&1
  }
}

[ "${quiet}" ] || {
  printf "\n\tInstalling tmux plugins ..."
}
[ -x ${TPM}/bin/install_plugins ] && ${TPM}/bin/install_plugins > /dev/null 2>&1

# If there is no user beets plugin folder
# then copy the MusicPlayerPlus beets plugin folder
# into the user's home and install these plugins
[ "${quiet}" ] || {
  printf "\n\tInstalling custom Beets plugins ..."
}
for plugin in ${MPPCDIR}/beets/plugins/*
do
  [ "${plugin}" == "${MPPCDIR}/beets/plugins/*" ] && continue
  [ -d "${plugin}" ] && {
    plugbase=`basename "${plugin}"`
    [ -d "${BEETSCONFDIR}/plugins/${plugbase}" ] || {
      # Inside the loop so it does not get created unless needed
      [ -d ${BEETSCONFDIR}/plugins ] || mkdir -p ${BEETSCONFDIR}/plugins
      cp -a "${plugin}" "${BEETSCONFDIR}/plugins/${plugbase}"
    }
  }
done

for plugin in ${BEETSCONFDIR}/plugins/*
do
  [ "${plugin}" == "${BEETSCONFDIR}/plugins/*" ] && continue
  [ -x "${plugin}/setup.py" ] && {
    cd "${plugin}"
    ./setup.py install --user > /dev/null 2>&1
  }
done

have_pip=`type -p pip`
if [ "${have_pip}" ]
then
  [ "${quiet}" ] || {
    printf "\n\tInstalling Python modules and Beets plugins ..."
  }
  if [ "${beetsdev}" ]
  then
    # To install latest Beets source tarball:
    #    - Uninstall Beets (python -m pip uninstall beets)
    #    - pip install https://github.com/beetbox/beets/tarball/master
    ${PYTHON} -m pip uninstall beets > /dev/null 2>&1
    ${PYTHON} -m pip install --user \
      https://github.com/beetbox/beets/tarball/master > /dev/null 2>&1
    BEETS=
  else
    BEETS=beets
  fi

  # If yt-dlp is already installed then do not install it with Pip
  have_ytdlp=`type -p yt-dlp`
  if [ "${have_ytdlp}" ]
  then
    YT_DLP=
  else
    YT_DLP="yt-dlp"
  fi

  # YAMScrobbler must be installed prior to beetcamp plus
  # PyPi is confused about the latest release version
  YMIN="0.7"
  SCRB="YAMScrobbler"
  [ "${quiet}" ] || {
    printf "\n\tEnsure YAMScrobbler module is current version ..."
  }
  if pip list | grep ${SCRB} > /dev/null
  then
    # Ensure YAMScrobbler is version ${YMIN} or greater
    [ -x ${SCPTDIR}/vercomp.sh ] && {
      YSCV=`${PYTHON} -m pip show ${SCRB} | grep Version: | awk ' { print $2 } '`
      # Only check first two digits of version as they screwed up
      YSCV=${YSCV:0:3}
      ${SCPTDIR}/vercomp.sh "${YSCV}" "${YMIN}" > /dev/null
      [ $? -eq 2 ] && {
        ${PYTHON} -m pip install --user ${SCRB}==0.7.3 > /dev/null 2>&1
      }
    }
  else
    ${PYTHON} -m pip install --user ${SCRB}==0.7.3 > /dev/null 2>&1
  fi
  [ "${quiet}" ] || printf "\n\tModules:"
  for pkg in unidecode six PySocks asciimatics beautifulsoup4 ${BEETS} \
             pylast beets-describe beets-yearfixer beetcamp beets-xtractor \
             python-mpd2 requests sacad tmuxp ueberzug ${YT_DLP} \
             calliope-music bandcamp-downloader scdl flask-cors
  do
    pip_install "${pkg}"
  done
  [ "${quiet}" ] || printf " done!\n"
else
  echo ""
  echo "WARNING: Python pip module not found."
  echo "Pip is required to install several MusicPlayerPlus components."
  echo ""
  echo "Install the Python pip module with:"
  printf "\n\tsudo apt install python3-pip\n"
  echo "or"
  printf "\n\tsudo dnf install python3-pip\n"
  echo ""
  echo "After verifying that pip is installed,"
  echo "rerun the 'mppinit' MusicPlayer initialization."
fi

[ "${quiet}" ] || {
  printf "\n\tVerifying minimum version of Python PyYAML module is installed ..."
}
# Minimum version of PyYAML, 5.1 would do but we use the latest 5.x release
VMIN="5.4.1"
# Ensure PyYAML is version ${VMIN} or greater
YAMV=`${PYTHON} -m pip show PyYAML | grep Version: | awk ' { print $2 } '`
[ -x ${SCPTDIR}/vercomp.sh ] && {
  ${SCPTDIR}/vercomp.sh "${YAMV}" "${VMIN}" > /dev/null
  [ $? -eq 2 ] && {
    # Update Python PyYAML to get support for safe_load of lastgenre
    # Beets plugin when used with Python 3.10
    # Specify version ${VMIN} to avoid updating to version 6
    YLOC=`${PYTHON} -m pip show PyYAML | grep Location: | awk ' { print $2 } '`
    pylocal=
    echo "${YLOC}" | grep "${HOME}" > /dev/null && pylocal=1
    if [ "${pylocal}" ]
    then
      ${PYTHON} -m pip install PyYAML==${VMIN} > /dev/null 2>&1
    else
      sudo ${PYTHON} -m pip install PyYAML==${VMIN} > /dev/null 2>&1
    fi
  }
}

[ "${quiet}" ] || {
  printf "\n\tPatching Beets plugins ..."
}

# Patch beets-web plugin
have_web=
SITE=`${PYTHON} -m site --user-site`
WEBP="${SITE}/beetsplug/web/__init__.py"
if [ -f "${WEBP}" ]
then
  have_web="${WEBP}"
else
  SITE=`${PYTHON} -m pip show beets | grep Location: | awk ' { print $2 } '`
  WEBP="${SITE}/beetsplug/beetsplug/web/__init__.py"
  [ -f "${WEBP}" ] && have_web="${WEBP}"
fi

[ "${have_web}" ] && {
  grep attachment_filename "${have_web}" > /dev/null && {
    cat "${have_web}" | \
      sed -e "s/attachment_filename/download_name/" > /tmp/web$$
    cp /tmp/web$$ "${have_web}"
    rm -f /tmp/web$$
  }
  grep "','.join(\[v" "${have_web}" > /dev/null && {
    cat "${have_web}" | sed -e "s%','.join(\[v%'/'.join(\[v%" > /tmp/web$$
    cp /tmp/web$$ "${have_web}"
    rm -f /tmp/web$$
  }
}

# Patch xtractor plugin
have_xtractor=
SITE=`${PYTHON} -m site --user-site`
XTRA="${SITE}/beetsplug/xtractor/command.py"
if [ -f "${XTRA}" ]
then
  have_xtractor="${XTRA}"
else
  SITE=`${PYTHON} -m pip show beets-xtractor | grep Location: | awk ' { print $2 } '`
  XTRA="${SITE}/beetsplug/xtractor/command.py"
  [ -f "${XTRA}" ] && have_xtractor="${XTRA}"
fi

[ "${have_xtractor}" ] && {
  grep self._run_write_to_item "${have_xtractor}" > /dev/null && {
    cat "${have_xtractor}" | \
      sed -e "s/# self._run_write_to_item/self._run_write_to_item/" \
          -e "s%if not identifier:%if (not identifier or identifier.find('/') != -1):%" > /tmp/ext$$
    cp /tmp/ext$$ "${have_xtractor}"
    rm -f /tmp/ext$$
  }
}

[ "${quiet}" ] || {
  printf "\n\tSyncing music directory across configs ..."
}
sync_music_dir

printf " done.\n"

printf "\n${BOLD}MusicPlayerPlus Initialization Complete${NORM}\n"
printf "\nMusic directory set to ${BOLD}${mpd_music}${NORM} in ${MPDCONF}"
printf "\nModify ${MPDCONF} 'music_directory' to change this."
printf "\nIf 'music_directory' is modified, run '${BOLD}mppinit sync${NORM}'\n"
printf "\nDownload albums in your Bandcamp collections with:"
printf "\n\t${BOLD}mppinit bandcamp${NORM}"
printf "\nDownload favorites in your Soundcloud account with:"
printf "\n\t${BOLD}mppinit soundcloud${NORM}"
printf "\nImport the music library into the Beets media management system:"
printf "\n\t${BOLD}mppinit import${NORM}"
printf "\nAfter the import has completed, perform an update of the Beets"
printf "\nlibrary metadata, genres, and album cover art:"
printf "\n\t${BOLD}mppinit metadata${NORM}"
printf "\nActivate the YAMS Last.fm scrobbler:"
printf "\n\t${BOLD}mppinit yams${NORM}\n"
visit_wiki
