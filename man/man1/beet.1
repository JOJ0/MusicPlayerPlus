.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "BEET" "1" "July 12, 2022" "beets 1.6.0" "User Manual"
.hy
.SH NAME
.PP
beet - command-line interface to beets
.SS SYNOPSIS
.PP
| \f[B]beet\f[R] [\f[I]args\f[R]...]
\f[I]command\f[R] [\f[I]args\f[R]...]
| \f[B]beet help\f[R] \f[I]command\f[R] :::
.PP
::: only html
.PP
\f[B]beet\f[R] is the command-line interface to beets.
.PP
You invoke beets by specifying a \f[I]command\f[R], like so:
.IP
.nf
\f[C]
beet COMMAND [ARGS...]
\f[R]
.fi
.PP
The rest of this document describes the available commands.
If you ever need a quick list of what\[aq]s available, just type
\f[V]beet help\f[R] or \f[V]beet help COMMAND\f[R] for help with a
specific command.
.PP
Beets also offers shell completion.
For bash, see the completion command; for zsh, see the accompanying
completion
script (https://github.com/beetbox/beets/blob/master/extra/_beet) for
the \f[V]beet\f[R] command.
:::
.SS Commands
.PP
::: only html
.PP
Here are the built-in commands available in beets:
.PP
::: {.contents local=\[dq]\[dq] depth=\[dq]1\[dq]} :::
.PP
Also be sure to see the
\f[V]global flags <global-flags>\f[R]{.interpreted-text
role=\[dq]ref\[dq]}.
:::
.SS import {#import-cmd}
.IP
.nf
\f[C]
beet import [-CWAPRqst] [-l LOGPATH] PATH...
beet import [options] -L QUERY
\f[R]
.fi
.PP
Add music to your library, attempting to get correct tags for it from
MusicBrainz.
.PP
Point the command at some music: directories, single files, or
compressed archives.
The music will be copied to a configurable directory structure and added
to a library database.
The command is interactive and will try to get you to verify MusicBrainz
tags that it thinks are suspect.
See the \f[V]autotagging guide </guides/tagger>\f[R]{.interpreted-text
role=\[dq]doc\[dq]} for detail on how to use the interactive
tag-correction flow.
.PP
Directories passed to the import command can contain either a single
album or many, in which case the leaf directories will be considered
albums (the latter case is true of typical Artist/Album organizations
and many people\[aq]s \[dq]downloads\[dq] folders).
The path can also be a single song or an archive.
Beets supports [zip]{.title-ref} and [tar]{.title-ref} archives out of
the box.
To extract [rar]{.title-ref} files, install the
rarfile (https://pypi.python.org/pypi/rarfile/) package and the
[unrar]{.title-ref} command.
To extract [7z]{.title-ref} files, install the
py7zr (https://pypi.org/project/py7zr/) package.
.PP
Optional command flags:
.IP \[bu] 2
By default, the command copies files to your library directory and
updates the ID3 tags on your music.
In order to move the files, instead of copying, use the \f[V]-m\f[R]
(move) option.
If you\[aq]d like to leave your music files untouched, try the
\f[V]-C\f[R] (don\[aq]t copy) and \f[V]-W\f[R] (don\[aq]t write tags)
options.
You can also disable this behavior by default in the configuration file
(below).
.IP \[bu] 2
Also, you can disable the autotagging behavior entirely using
\f[V]-A\f[R] (don\[aq]t autotag)---then your music will be imported with
its existing metadata.
.IP \[bu] 2
During a long tagging import, it can be useful to keep track of albums
that weren\[aq]t tagged successfully---either because they\[aq]re not in
the MusicBrainz database or because something\[aq]s wrong with the
files.
Use the \f[V]-l\f[R] option to specify a filename to log every time you
skip an album or import it \[dq]as-is\[dq] or an album gets skipped as a
duplicate.
You can later review the file manually or import skipped paths from the
logfile automatically by using the \f[V]--from-logfile LOGFILE\f[R]
argument.
.IP \[bu] 2
Relatedly, the \f[V]-q\f[R] (quiet) option can help with large imports
by autotagging without ever bothering to ask for user input.
Whenever the normal autotagger mode would ask for confirmation, the
quiet mode pessimistically skips the album.
The quiet mode also disables the tagger\[aq]s ability to resume
interrupted imports.
.IP \[bu] 2
Speaking of resuming interrupted imports, the tagger will prompt you if
it seems like the last import of the directory was interrupted (by you
or by a crash).
If you want to skip this prompt, you can say \[dq]yes\[dq] automatically
by providing \f[V]-p\f[R] or \[dq]no\[dq] using \f[V]-P\f[R].
The resuming feature can be disabled by default using a configuration
option (see below).
.IP \[bu] 2
If you want to import only the \f[I]new\f[R] stuff from a directory, use
the \f[V]-i\f[R] option to run an \f[I]incremental\f[R] import.
With this flag, beets will keep track of every directory it ever imports
and avoid importing them again.
This is useful if you have an \[dq]incoming\[dq] directory that you
periodically add things to.
To get this to work correctly, you\[aq]ll need to use an incremental
import \f[I]every time\f[R] you run an import on the directory in
question---including the first time, when no subdirectories will be
skipped.
So consider enabling the \f[V]incremental\f[R] configuration option.
.IP \[bu] 2
When beets applies metadata to your music, it will retain the value of
any existing tags that weren\[aq]t overwritten, and import them into the
database.
You may prefer to only use existing metadata for finding matches, and to
erase it completely when new metadata is applied.
You can enforce this behavior with the \f[V]--from-scratch\f[R] option,
or the \f[V]from_scratch\f[R] configuration option.
.IP \[bu] 2
By default, beets will proceed without asking if it finds a very close
metadata match.
To disable this and have the importer ask you every time, use the
\f[V]-t\f[R] (for \f[I]timid\f[R]) option.
.IP \[bu] 2
The importer typically works in a whole-album-at-a-time mode.
If you instead want to import individual, non-album tracks, use the
\f[I]singleton\f[R] mode by supplying the \f[V]-s\f[R] option.
.IP \[bu] 2
If you have an album that\[aq]s split across several directories under a
common top directory, use the \f[V]--flat\f[R] option.
This takes all the music files under the directory (recursively) and
treats them as a single large album instead of as one album per
directory.
This can help with your more stubborn multi-disc albums.
.IP \[bu] 2
Similarly, if you have one directory that contains multiple albums, use
the \f[V]--group-albums\f[R] option to split the files based on their
metadata before matching them as separate albums.
.IP \[bu] 2
If you want to preview which files would be imported, use the
\f[V]--pretend\f[R] option.
If set, beets will just print a list of files that it would otherwise
import.
.IP \[bu] 2
If you already have a metadata backend ID that matches the items to be
imported, you can instruct beets to restrict the search to that ID
instead of searching for other candidates by using the
\f[V]--search-id SEARCH_ID\f[R] option.
Multiple IDs can be specified by simply repeating the option several
times.
.IP \[bu] 2
You can supply \f[V]--set field=value\f[R] to assign [field]{.title-ref}
to [value]{.title-ref} on import.
These assignments will merge with (and possibly override) the
\f[V]set_fields\f[R]{.interpreted-text role=\[dq]ref\[dq]} configuration
dictionary.
You can use the option multiple times on the command line, like so:
.RS 2
.IP
.nf
\f[C]
beet import --set genre=\[dq]Alternative Rock\[dq] --set mood=\[dq]emotional\[dq]
\f[R]
.fi
.RE
.PP
::: only html
.SS Reimporting {#reimport}
.PP
The \f[V]import\f[R] command can also be used to \[dq]reimport\[dq]
music that you\[aq]ve already added to your library.
This is useful when you change your mind about some selections you made
during the initial import, or if you prefer to import everything
\[dq]as-is\[dq] and then correct tags later.
.PP
Just point the \f[V]beet import\f[R] command at a directory of files
that are already catalogged in your library.
Beets will automatically detect this situation and avoid duplicating any
items.
In this situation, the \[dq]copy files\[dq] option
(\f[V]-c\f[R]/\f[V]-C\f[R] on the command line or \f[V]copy\f[R] in the
config file) has slightly different behavior: it causes files to be
\f[I]moved\f[R], rather than duplicated, if they\[aq]re already in your
library.
(The same is true, of course, if \f[V]move\f[R] is enabled.)
That is, your directory structure will be updated to reflect the new
tags if copying is enabled; you never end up with two copies of the
file.
.PP
The \f[V]-L\f[R] (\f[V]--library\f[R]) flag is also useful for
retagging.
Instead of listing paths you want to import on the command line, specify
a \f[V]query string <query>\f[R]{.interpreted-text role=\[dq]doc\[dq]}
that matches items from your library.
In this case, the \f[V]-s\f[R] (singleton) flag controls whether the
query matches individual items or full albums.
If you want to retag your whole library, just supply a null query, which
matches everything: \f[V]beet import -L\f[R]
.PP
Note that, if you just want to update your files\[aq] tags according to
changes in the MusicBrainz database, the
\f[V]/plugins/mbsync\f[R]{.interpreted-text role=\[dq]doc\[dq]} is a
better choice.
Reimporting uses the full matching machinery to guess metadata matches;
\f[V]mbsync\f[R] just relies on MusicBrainz IDs.
:::
.SS list {#list-cmd}
.IP
.nf
\f[C]
beet list [-apf] QUERY
\f[R]
.fi
.PP
\f[V]Queries <query>\f[R]{.interpreted-text role=\[dq]doc\[dq]} the
database for music.
.PP
Want to search for \[dq]Gronlandic Edit\[dq] by of Montreal?
Try \f[V]beet list gronlandic\f[R].
Maybe you want to see everything released in 2009 with
\[dq]vegetables\[dq] in the title?
Try \f[V]beet list year:2009 title:vegetables\f[R].
You can also specify the sort order.
(Read more in \f[V]query\f[R]{.interpreted-text role=\[dq]doc\[dq]}.)
.PP
You can use the \f[V]-a\f[R] switch to search for albums instead of
individual items.
In this case, the queries you use are restricted to album-level fields:
for example, you can search for \f[V]year:1969\f[R] but query parts for
item-level fields like \f[V]title:foo\f[R] will be ignored.
Remember that \f[V]artist\f[R] is an item-level field;
\f[V]albumartist\f[R] is the corresponding album field.
.PP
The \f[V]-p\f[R] option makes beets print out filenames of matched
items, which might be useful for piping into other Unix commands (such
as xargs (https://en.wikipedia.org/wiki/Xargs)).
Similarly, the \f[V]-f\f[R] option lets you specify a specific format
with which to print every album or track.
This uses the same template syntax as beets\[aq]
\f[V]path formats <pathformat>\f[R]{.interpreted-text
role=\[dq]doc\[dq]}.
For example, the command
\f[V]beet ls -af \[aq]$album: $albumtotal\[aq] beatles\f[R] prints out
the number of tracks on each Beatles album.
In Unix shells, remember to enclose the template argument in single
quotes to avoid environment variable expansion.
.SS remove {#remove-cmd}
.IP
.nf
\f[C]
beet remove [-adf] QUERY
\f[R]
.fi
.PP
Remove music from your library.
.PP
This command uses the same \f[V]query <query>\f[R]{.interpreted-text
role=\[dq]doc\[dq]} syntax as the \f[V]list\f[R] command.
By default, it just removes entries from the library database; it
doesn\[aq]t touch the files on disk.
To actually delete the files, use the \f[V]-d\f[R] flag.
When the \f[V]-a\f[R] flag is given, the command operates on albums
instead of individual tracks.
.PP
When you run the \f[V]remove\f[R] command, it prints a list of all
affected items in the library and asks for your permission before
removing them.
You can then choose to abort (type [n]{.title-ref}), confirm
([y]{.title-ref}), or interactively choose some of the items
([s]{.title-ref}).
In the latter case, the command will prompt you for every matching item
or album and invite you to type [y]{.title-ref} to remove the
item/album, [n]{.title-ref} to keep it or [q]{.title-ref} to exit and
only remove the items/albums selected up to this point.
This option lets you choose precisely which tracks/albums to remove
without spending too much time to carefully craft a query.
If you do not want to be prompted at all, use the \f[V]-f\f[R] option.
.SS modify {#modify-cmd}
.IP
.nf
\f[C]
beet modify [-MWay] [-f FORMAT] QUERY [FIELD=VALUE...] [FIELD!...]
\f[R]
.fi
.PP
Change the metadata for items or albums in the database.
.PP
Supply a \f[V]query <query>\f[R]{.interpreted-text role=\[dq]doc\[dq]}
matching the things you want to change and a series of
\f[V]field=value\f[R] pairs.
For example,
\f[V]beet modify genius of love artist=\[dq]Tom Tom Club\[dq]\f[R] will
change the artist for the track \[dq]Genius of Love.\[dq] To remove
fields (which is only possible for flexible attributes), follow a field
name with an exclamation point: \f[V]field!\f[R].
.PP
The \f[V]-a\f[R] switch also operates on albums in addition to the
individual tracks.
Without this flag, the command will only change \f[I]track-level\f[R]
data, even if all the tracks belong to the same album.
If you want to change an \f[I]album-level\f[R] field, such as
\f[V]year\f[R] or \f[V]albumartist\f[R], you\[aq]ll want to use the
\f[V]-a\f[R] flag to avoid a confusing situation where the data for
individual tracks conflicts with the data for the whole album.
.PP
Items will automatically be moved around when necessary if they\[aq]re
in your library directory, but you can disable that with \f[V]-M\f[R].
Tags will be written to the files according to the settings you have for
imports, but these can be overridden with \f[V]-w\f[R] (write tags, the
default) and \f[V]-W\f[R] (don\[aq]t write tags).
.PP
When you run the \f[V]modify\f[R] command, it prints a list of all
affected items in the library and asks for your permission before making
any changes.
You can then choose to abort the change (type [n]{.title-ref}), confirm
([y]{.title-ref}), or interactively choose some of the items
([s]{.title-ref}).
In the latter case, the command will prompt you for every matching item
or album and invite you to type [y]{.title-ref} to apply the changes,
[n]{.title-ref} to discard them or [q]{.title-ref} to exit and apply the
selected changes.
This option lets you choose precisely which data to change without
spending too much time to carefully craft a query.
To skip the prompts entirely, use the \f[V]-y\f[R] option.
.SS move {#move-cmd}
.IP
.nf
\f[C]
beet move [-capt] [-d DIR] QUERY
\f[R]
.fi
.PP
Move or copy items in your library.
.PP
This command, by default, acts as a library consolidator: items matching
the query are renamed into your library directory structure.
By specifying a destination directory with \f[V]-d\f[R] manually, you
can move items matching a query anywhere in your filesystem.
The \f[V]-c\f[R] option copies files instead of moving them.
As with other commands, the \f[V]-a\f[R] option matches albums instead
of items.
The \f[V]-e\f[R] flag (for \[dq]export\[dq]) copies files without
changing the database.
.PP
To perform a \[dq]dry run\[dq], just use the \f[V]-p\f[R] (for
\[dq]pretend\[dq]) flag.
This will show you a list of files that would be moved but won\[aq]t
actually change anything on disk.
The \f[V]-t\f[R] option sets the timid mode which will ask again before
really moving or copying the files.
.SS update {#update-cmd}
.IP
.nf
\f[C]
beet update [-F] FIELD [-aM] QUERY
\f[R]
.fi
.PP
Update the library (and, by default, move files) to reflect out-of-band
metadata changes and file deletions.
.PP
This will scan all the matched files and read their tags, populating the
database with the new values.
By default, files will be renamed according to their new metadata;
disable this with \f[V]-M\f[R].
Beets will skip files if their modification times have not changed, so
any out-of-band metadata changes must also update these for
\f[V]beet update\f[R] to recognise that the files have been edited.
.PP
To perform a \[dq]dry run\[dq] of an update, just use the \f[V]-p\f[R]
(for \[dq]pretend\[dq]) flag.
This will show you all the proposed changes but won\[aq]t actually
change anything on disk.
.PP
By default, all the changed metadata will be populated back to the
database.
If you only want certain fields to be written, specify them with the
\f[V]\[ga]-F\f[R][ flags (which can be used multiple times).
For the list of supported fields, please see
]{.title-ref}\f[V]beet fields\f[R]\[ga].
.PP
When an updated track is part of an album, the album-level fields of
\f[I]all\f[R] tracks from the album are also updated.
(Specifically, the command copies album-level data from the first track
on the album and applies it to the rest of the tracks.)
This means that, if album-level fields aren\[aq]t identical within an
album, some changes shown by the \f[V]update\f[R] command may be
overridden by data from other tracks on the same album.
This means that running the \f[V]update\f[R] command multiple times may
show the same changes being applied.
.SS write {#write-cmd}
.IP
.nf
\f[C]
beet write [-pf] [QUERY]
\f[R]
.fi
.PP
Write metadata from the database into files\[aq] tags.
.PP
When you make changes to the metadata stored in beets\[aq] library
database (during import or with the
\f[V]modify-cmd\f[R]{.interpreted-text role=\[dq]ref\[dq]} command, for
example), you often have the option of storing changes only in the
database, leaving your files untouched.
The \f[V]write\f[R] command lets you later change your mind and write
the contents of the database into the files.
By default, this writes the changes only if there is a difference
between the database and the tags in the file.
.PP
You can think of this command as the opposite of
\f[V]update-cmd\f[R]{.interpreted-text role=\[dq]ref\[dq]}.
.PP
The \f[V]-p\f[R] option previews metadata changes without actually
applying them.
.PP
The \f[V]-f\f[R] option forces a write to the file, even if the file
tags match the database.
This is useful for making sure that enabled plugins that run on write
(e.g., the Scrub and Zero plugins) are run on the file.
.SS stats {#stats-cmd}
.IP
.nf
\f[C]
beet stats [-e] [QUERY]
\f[R]
.fi
.PP
Show some statistics on your entire library (if you don\[aq]t provide a
\f[V]query <query>\f[R]{.interpreted-text role=\[dq]doc\[dq]}) or the
matched items (if you do).
.PP
By default, the command calculates file sizes using their bitrate and
duration.
The \f[V]-e\f[R] (\f[V]--exact\f[R]) option reads the exact sizes of
each file (but is slower).
The exact mode also outputs the exact duration in seconds.
.SS fields {#fields-cmd}
.IP
.nf
\f[C]
beet fields
\f[R]
.fi
.PP
Show the item and album metadata fields available for use in
\f[V]query\f[R]{.interpreted-text role=\[dq]doc\[dq]} and
\f[V]pathformat\f[R]{.interpreted-text role=\[dq]doc\[dq]}.
The listing includes any template fields provided by plugins and any
flexible attributes you\[aq]ve manually assigned to your items and
albums.
.SS config {#config-cmd}
.IP
.nf
\f[C]
beet config [-pdc]
beet config -e
\f[R]
.fi
.PP
Show or edit the user configuration.
This command does one of three things:
.IP \[bu] 2
With no options, print a YAML representation of the current user
configuration.
With the \f[V]--default\f[R] option, beets\[aq] default options are also
included in the dump.
.IP \[bu] 2
The \f[V]--path\f[R] option instead shows the path to your configuration
file.
This can be combined with the \f[V]--default\f[R] flag to show where
beets keeps its internal defaults.
.IP \[bu] 2
By default, sensitive information like passwords is removed when dumping
the configuration.
The \f[V]--clear\f[R] option includes this sensitive data.
.IP \[bu] 2
With the \f[V]--edit\f[R] option, beets attempts to open your config
file for editing.
It first tries the \f[V]$EDITOR\f[R] environment variable and then a
fallback option depending on your platform: \f[V]open\f[R] on OS X,
\f[V]xdg-open\f[R] on Unix, and direct invocation on Windows.
.SS Global Flags
.PP
Beets has a few \[dq]global\[dq] flags that affect all commands.
These must appear between the executable name (\f[V]beet\f[R]) and the
command---for example, \f[V]beet -v import ...\f[R].
.IP \[bu] 2
\f[V]-l LIBPATH\f[R]: specify the library database file to use.
.IP \[bu] 2
\f[V]-d DIRECTORY\f[R]: specify the library root directory.
.IP \[bu] 2
\f[V]-v\f[R]: verbose mode; prints out a deluge of debugging
information.
Please use this flag when reporting bugs.
You can use it twice, as in \f[V]-vv\f[R], to make beets even more
verbose.
.IP \[bu] 2
\f[V]-c FILE\f[R]: read a specified YAML
\f[V]configuration file <config>\f[R]{.interpreted-text
role=\[dq]doc\[dq]}.
This configuration works as an overlay: rather than replacing your
normal configuration options entirely, the two are merged.
Any individual options set in this config file will override the
corresponding settings in your base configuration.
.IP \[bu] 2
\f[V]-p plugins\f[R]: specify a comma-separated list of plugins to
enable.
If specified, the plugin list in your configuration is ignored.
The long form of this argument also allows specifying no plugins,
effectively disabling all plugins: \f[V]--plugins=\f[R].
.IP \[bu] 2
\f[V]-P plugins\f[R]: specify a comma-separated list of plugins to
disable in a specific beets run.
This will overwrite \f[V]-p\f[R] if used with it.
To disable all plugins, use \f[V]--plugins=\f[R] instead.
.PP
Beets also uses the \f[V]BEETSDIR\f[R] environment variable to look for
configuration and data.
.SS Shell Completion {#completion}
.PP
Beets includes support for shell command completion.
The command \f[V]beet completion\f[R] prints out a
bash (https://www.gnu.org/software/bash/) 3.2 script; to enable
completion put a line like this into your \f[V].bashrc\f[R] or similar
file:
.IP
.nf
\f[C]
eval \[dq]$(beet completion)\[dq]
\f[R]
.fi
.PP
Or, to avoid slowing down your shell startup time, you can pipe the
\f[V]beet completion\f[R] output to a file and source that instead.
.PP
You will also need to source the
bash-completion (https://github.com/scop/bash-completion) script, which
is probably available via your package manager.
On OS X, you can install it via Homebrew with
\f[V]brew install bash-completion\f[R]; Homebrew will give you
instructions for sourcing the script.
.PP
The completion script suggests names of subcommands and (after typing
\f[V]-\f[R]) options of the given command.
If you are using a command that accepts a query, the script will also
complete field names.
:
.IP
.nf
\f[C]
beet list ar[TAB]
# artist:  artist_credit:  artist_sort:  artpath:
beet list artp[TAB]
beet list artpath\[rs]:
\f[R]
.fi
.PP
(Don\[aq]t worry about the slash in front of the colon: this is a escape
sequence for the shell and won\[aq]t be seen by beets.)
.PP
Completion of plugin commands only works for those plugins that were
enabled when running \f[V]beet completion\f[R].
If you add a plugin later on you will want to re-generate the script.
.SS zsh
.PP
If you use zsh, take a look at the included completion
script (https://github.com/beetbox/beets/blob/master/extra/_beet).
The script should be placed in a directory that is part of your
\f[V]fpath\f[R], and [not]{.title-ref} sourced in your \f[V].zshrc\f[R].
Running \f[V]echo $fpath\f[R] will give you a list of valid directories.
.PP
Another approach is to use zsh\[aq]s bash completion compatibility.
This snippet defines some bash-specific functions to make this work
without errors:
.IP
.nf
\f[C]
autoload bashcompinit
bashcompinit
_get_comp_words_by_ref() { :; }
compopt() { :; }
_filedir() { :; }
eval \[dq]$(beet completion)\[dq]
\f[R]
.fi
.SH Queries
.PP
Many of beets\[aq] \f[V]commands <cli>\f[R]{.interpreted-text
role=\[dq]doc\[dq]} are built around \f[B]query strings:\f[R] searches
that select tracks and albums from your library.
This page explains the query string syntax, which is meant to vaguely
resemble the syntax used by Web search engines.
.SS Keyword {#keywordquery}
.PP
This command:
.IP
.nf
\f[C]
$ beet list love
\f[R]
.fi
.PP
will show all tracks matching the query string \f[V]love\f[R].
By default any unadorned word like this matches in a track\[aq]s title,
artist, album name, album artist, genre and comments.
See below on how to search other fields.
.PP
For example, this is what I might see when I run the command above:
.IP
.nf
\f[C]
Against Me! - Reinventing Axl Rose - I Still Love You Julie
Air - Love 2 - Do the Joy
Bag Raiders - Turbo Love - Shooting Stars
Bat for Lashes - Two Suns - Good Love
\&...
\f[R]
.fi
.SS Combining Keywords {#combiningqueries}
.PP
Multiple keywords are implicitly joined with a Boolean \[dq]and.\[dq]
That is, if a query has two keywords, it only matches tracks that
contain \f[I]both\f[R] keywords.
For example, this command:
.IP
.nf
\f[C]
$ beet ls magnetic tomorrow
\f[R]
.fi
.PP
matches songs from the album \[dq]The House of Tomorrow\[dq] by The
Magnetic Fields in my library.
It \f[I]doesn\[aq]t\f[R] match other songs by the Magnetic Fields, nor
does it match \[dq]Tomorrowland\[dq] by Walter Meego---those songs only
have \f[I]one\f[R] of the two keywords I specified.
.PP
Keywords can also be joined with a Boolean \[dq]or\[dq] using a comma.
For example, the command:
.IP
.nf
\f[C]
$ beet ls magnetic tomorrow , beatles yesterday
\f[R]
.fi
.PP
will match both \[dq]The House of Tomorrow\[dq] by the Magnetic Fields,
as well as \[dq]Yesterday\[dq] by The Beatles.
Note that the comma has to be followed by a space (e.g.,
\f[V]foo,bar\f[R] will be treated as a single keyword, \f[I]not\f[R] as
an OR-query).
.SS Specific Fields
.PP
Sometimes, a broad keyword match isn\[aq]t enough.
Beets supports a syntax that lets you query a specific field---only the
artist, only the track title, and so on.
Just say \f[V]field:value\f[R], where \f[V]field\f[R] is the name of the
thing you\[aq]re trying to match (such as \f[V]artist\f[R],
\f[V]album\f[R], or \f[V]title\f[R]) and \f[V]value\f[R] is the keyword
you\[aq]re searching for.
.PP
For example, while this query:
.IP
.nf
\f[C]
$ beet list dream
\f[R]
.fi
.PP
matches a lot of songs in my library, this more-specific query:
.IP
.nf
\f[C]
$ beet list artist:dream
\f[R]
.fi
.PP
only matches songs by the artist The-Dream.
One query I especially appreciate is one that matches albums by year:
.IP
.nf
\f[C]
$ beet list -a year:2012
\f[R]
.fi
.PP
Recall that \f[V]-a\f[R] makes the \f[V]list\f[R] command show albums
instead of individual tracks, so this command shows me all the releases
I have from this year.
.SS Phrases
.PP
You can query for strings with spaces in them by quoting or escaping
them using your shell\[aq]s argument syntax.
For example, this command:
.IP
.nf
\f[C]
$ beet list the rebel
\f[R]
.fi
.PP
shows several tracks in my library, but these (equivalent) commands:
.IP
.nf
\f[C]
$ beet list \[dq]the rebel\[dq]
$ beet list the\[rs] rebel
\f[R]
.fi
.PP
only match the track \[dq]The Rebel\[dq] by Buck 65.
Note that the quotes and backslashes are not part of beets\[aq] syntax;
I\[aq]m just using the escaping functionality of my shell (bash or zsh,
for instance) to pass \f[V]the rebel\f[R] as a single argument instead
of two.
.SS Exact Matches
.PP
While ordinary queries perform \f[I]substring\f[R] matches, beets can
also match whole strings by adding either \f[V]=\f[R] (case-sensitive)
or \f[V]\[ti]\f[R] (ignore case) after the field name\[aq]s colon and
before the expression:
.IP
.nf
\f[C]
$ beet list artist:air
$ beet list artist:\[ti]air
$ beet list artist:=AIR
\f[R]
.fi
.PP
The first query is a simple substring one that returns tracks by Air,
AIR, and Air Supply.
The second query returns tracks by Air and AIR, since both are a
case-insensitive match for the entire expression, but does not return
anything by Air Supply.
The third query, which requires a case-sensitive exact match, returns
tracks by AIR only.
.PP
Exact matches may be performed on phrases as well:
.IP
.nf
\f[C]
$ beet list artist:\[ti]\[dq]dave matthews\[dq]
$ beet list artist:=\[dq]Dave Matthews\[dq]
\f[R]
.fi
.PP
Both of these queries return tracks by Dave Matthews, but not by Dave
Matthews Band.
.PP
To search for exact matches across \f[I]all\f[R] fields, just prefix the
expression with a single \f[V]=\f[R] or \f[V]\[ti]\f[R]:
.IP
.nf
\f[C]
$ beet list \[ti]crash
$ beet list =\[dq]American Football\[dq]
\f[R]
.fi
.SS Regular Expressions {#regex}
.PP
In addition to simple substring and exact matches, beets also supports
regular expression matching for more advanced queries.
To run a regex query, use an additional \f[V]:\f[R] between the field
name and the expression:
.IP
.nf
\f[C]
$ beet list \[dq]artist::Ann(a|ie)\[dq]
\f[R]
.fi
.PP
That query finds songs by Anna Calvi and Annie but not Annuals.
Similarly, this query prints the path to any file in my library
that\[aq]s missing a track title:
.IP
.nf
\f[C]
$ beet list -p title::\[ha]$
\f[R]
.fi
.PP
To search \f[I]all\f[R] fields using a regular expression, just prefix
the expression with a single \f[V]:\f[R], like so:
.IP
.nf
\f[C]
$ beet list \[dq]:Ho[pm]eless\[dq]
\f[R]
.fi
.PP
Regular expressions are case-sensitive and build on Python\[aq]s
built-in implementation (https://docs.python.org/library/re.html).
See Python\[aq]s documentation for specifics on regex syntax.
.PP
Most command-line shells will try to interpret common characters in
regular expressions, such as \f[V]()[]|\f[R].
To type those characters, you\[aq]ll need to escape them (e.g., with
backslashes or quotation marks, depending on your shell).
.SS Numeric Range Queries {#numericquery}
.PP
For numeric fields, such as year, bitrate, and track, you can query
using one-or two-sided intervals.
That is, you can find music that falls within a \f[I]range\f[R] of
values.
To use ranges, write a query that has two dots (\f[V]..\f[R]) at the
beginning, middle, or end of a string of numbers.
Dots in the beginning let you specify a maximum (e.g., \f[V]..7\f[R]);
dots at the end mean a minimum (\f[V]4..\f[R]); dots in the middle mean
a range (\f[V]4..7\f[R]).
.PP
For example, this command finds all your albums that were released in
the \[aq]90s:
.IP
.nf
\f[C]
$ beet list -a year:1990..1999
\f[R]
.fi
.PP
and this command finds MP3 files with bitrates of 128k or lower:
.IP
.nf
\f[C]
$ beet list format:MP3 bitrate:..128000
\f[R]
.fi
.PP
The \f[V]length\f[R] field also lets you use a \[dq]M:SS\[dq] format.
For example, this query finds tracks that are less than four and a half
minutes in length:
.IP
.nf
\f[C]
$ beet list length:..4:30
\f[R]
.fi
.SS Date and Date Range Queries {#datequery}
.PP
Date-valued fields, such as \f[I]added\f[R] and \f[I]mtime\f[R], have a
special query syntax that lets you specify years, months, and days as
well as ranges between dates.
.PP
Dates are written separated by hyphens, like \f[V]year-month-day\f[R],
but the month and day are optional.
If you leave out the day, for example, you will get matches for the
whole month.
.PP
Date \f[I]intervals\f[R], like the numeric intervals described above,
are separated by two dots (\f[V]..\f[R]).
You can specify a start, an end, or both.
.PP
Here is an example that finds all the albums added in 2008:
.IP
.nf
\f[C]
$ beet ls -a \[aq]added:2008\[aq]
\f[R]
.fi
.PP
Find all items added in the years 2008, 2009 and 2010:
.IP
.nf
\f[C]
$ beet ls \[aq]added:2008..2010\[aq]
\f[R]
.fi
.PP
Find all items added before the year 2010:
.IP
.nf
\f[C]
$ beet ls \[aq]added:..2009\[aq]
\f[R]
.fi
.PP
Find all items added on or after 2008-12-01 but before 2009-10-12:
.IP
.nf
\f[C]
$ beet ls \[aq]added:2008-12..2009-10-11\[aq]
\f[R]
.fi
.PP
Find all items with a file modification time between 2008-12-01 and
2008-12-03:
.IP
.nf
\f[C]
$ beet ls \[aq]mtime:2008-12-01..2008-12-02\[aq]
\f[R]
.fi
.PP
You can also add an optional time value to date queries, specifying
hours, minutes, and seconds.
.PP
Times are separated from dates by a space, an uppercase \[aq]T\[aq] or a
lowercase \[aq]t\[aq], for example: \f[V]2008-12-01T23:59:59\f[R].
If you specify a time, then the date must contain a year, month, and
day.
The minutes and seconds are optional.
.PP
Here is an example that finds all items added on 2008-12-01 at or after
22:00 but before 23:00:
.IP
.nf
\f[C]
$ beet ls \[aq]added:2008-12-01T22\[aq]
\f[R]
.fi
.PP
To find all items added on or after 2008-12-01 at 22:45:
.IP
.nf
\f[C]
$ beet ls \[aq]added:2008-12-01T22:45..\[aq]
\f[R]
.fi
.PP
To find all items added on 2008-12-01, at or after 22:45:20 but before
22:45:41:
.IP
.nf
\f[C]
$ beet ls \[aq]added:2008-12-01T22:45:20..2008-12-01T22:45:40\[aq]
\f[R]
.fi
.PP
Here are example of the three ways to separate dates from times.
All of these queries do the same thing:
.IP
.nf
\f[C]
$ beet ls \[aq]added:2008-12-01T22:45:20\[aq]
$ beet ls \[aq]added:2008-12-01t22:45:20\[aq]
$ beet ls \[aq]added:2008-12-01 22:45:20\[aq]
\f[R]
.fi
.PP
You can also use \f[I]relative\f[R] dates.
For example, \f[V]-3w\f[R] means three weeks ago, and \f[V]+4d\f[R]
means four days in the future.
A relative date has three parts:
.IP \[bu] 2
Either \f[V]+\f[R] or \f[V]-\f[R], to indicate the past or the future.
The sign is optional; if you leave this off, it defaults to the future.
.IP \[bu] 2
A number.
.IP \[bu] 2
A letter indicating the unit: \f[V]d\f[R], \f[V]w\f[R], \f[V]m\f[R] or
\f[V]y\f[R], meaning days, weeks, months or years.
(A \[dq]month\[dq] is always 30 days and a \[dq]year\[dq] is always 365
days.)
.PP
Here\[aq]s an example that finds all the albums added since last week:
.IP
.nf
\f[C]
$ beet ls -a \[aq]added:-1w..\[aq]
\f[R]
.fi
.PP
And here\[aq]s an example that lists items added in a two-week period
starting four weeks ago:
.IP
.nf
\f[C]
$ beet ls \[aq]added:-6w..-4w\[aq]
\f[R]
.fi
.SS Query Term Negation {#not_query}
.PP
Query terms can also be negated, acting like a Boolean \[dq]not,\[dq] by
prefixing them with \f[V]-\f[R] or \f[V]\[ha]\f[R].
This has the effect of returning all the items that do \f[B]not\f[R]
match the query term.
For example, this command:
.IP
.nf
\f[C]
$ beet list \[ha]love
\f[R]
.fi
.PP
matches all the songs in the library that do not have \[dq]love\[dq] in
any of their fields.
.PP
Negation can be combined with the rest of the query mechanisms, so you
can negate specific fields, regular expressions, etc.
For example, this command:
.IP
.nf
\f[C]
$ beet list -a artist:dylan \[ha]year:1980..1989 \[dq]\[ha]album::the(y)?\[dq]
\f[R]
.fi
.PP
matches all the albums with an artist containing \[dq]dylan\[dq], but
excluding those released in the eighties and those that have
\[dq]the\[dq] or \[dq]they\[dq] on the title.
.PP
The syntax supports both \f[V]\[ha]\f[R] and \f[V]-\f[R] as synonyms
because the latter indicates flags on the command line.
To use a minus sign in a command-line query, use a double dash
\f[V]--\f[R] to separate the options from the query:
.IP
.nf
\f[C]
$ beet list -a -- artist:dylan -year:1980..1990 \[dq]-album::the(y)?\[dq]
\f[R]
.fi
.SS Path Queries {#pathquery}
.PP
Sometimes it\[aq]s useful to find all the items in your library that are
(recursively) inside a certain directory.
Use the \f[V]path:\f[R] field to do this:
.IP
.nf
\f[C]
$ beet list path:/my/music/directory
\f[R]
.fi
.PP
In fact, beets automatically recognizes any query term containing a path
separator (\f[V]/\f[R] on POSIX systems) as a path query if that path
exists, so this command is equivalent as long as
\f[V]/my/music/directory\f[R] exist:
.IP
.nf
\f[C]
$ beet list /my/music/directory
\f[R]
.fi
.PP
Note that this only matches items that are \f[I]already in your
library\f[R], so a path query won\[aq]t necessarily find \f[I]all\f[R]
the audio files in a directory---just the ones you\[aq]ve already added
to your beets library.
.PP
Path queries are case sensitive if the queried path is on a
case-sensitive filesystem.
.SS Sort Order {#query-sort}
.PP
Queries can specify a sort order.
Use the name of the [field]{.title-ref} you want to sort on, followed by
a \f[V]+\f[R] or \f[V]-\f[R] sign to indicate ascending or descending
sort.
For example, this command:
.IP
.nf
\f[C]
$ beet list -a year+
\f[R]
.fi
.PP
will list all albums in chronological order.
You can also specify several sort orders, which will be used in the same
order as they appear in your query:
.IP
.nf
\f[C]
$ beet list -a genre+ year+
\f[R]
.fi
.PP
This command will sort all albums by genre and, in each genre, in
chronological order.
.PP
The \f[V]artist\f[R] and \f[V]albumartist\f[R] keys are special: they
attempt to use their corresponding \f[V]artist_sort\f[R] and
\f[V]albumartist_sort\f[R] fields for sorting transparently (but fall
back to the ordinary fields when those are empty).
.PP
Lexicographic sorts are case insensitive by default, resulting in the
following sort order: \f[V]Bar foo Qux\f[R].
This behavior can be changed with the
\f[V]sort_case_insensitive\f[R]{.interpreted-text role=\[dq]ref\[dq]}
configuration option.
Case sensitive sort will result in lower-case values being placed after
upper-case values, e.g., \f[V]Bar Qux foo\f[R].
.PP
Note that when sorting by fields that are not present on all items (such
as flexible fields, or those defined by plugins) in \f[I]ascending\f[R]
order, the items that lack that particular field will be listed at the
\f[I]beginning\f[R] of the list.
.PP
You can set the default sorting behavior with the
\f[V]sort_item\f[R]{.interpreted-text role=\[dq]ref\[dq]} and
\f[V]sort_album\f[R]{.interpreted-text role=\[dq]ref\[dq]} configuration
options.
.SS See Also
.PP
\f[V]https://beets.readthedocs.org/\f[R]
.PP
\f[V]beetsconfig(5)\f[R]{.interpreted-text role=\[dq]manpage\[dq]}
